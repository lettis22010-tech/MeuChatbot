import { ZodSchema } from 'zod';

/**
 * Base client for Websets API
 */

/**
 * Type for API query parameters
 */
type QueryParams$1 = Record<string, string | number | boolean | string[] | undefined>;
/**
 * Type for API request body
 */
interface RequestBody$1 {
    [key: string]: unknown;
}
/**
 * Common pagination parameters
 */
interface PaginationParams {
    /**
     * Cursor for pagination
     */
    cursor?: string;
    /**
     * Maximum number of items per page
     */
    limit?: number;
}
/**
 * Base client class for all Websets-related API clients
 */
declare class WebsetsBaseClient {
    protected client: Exa;
    /**
     * Initialize a new Websets base client
     * @param client The Exa client instance
     */
    constructor(client: Exa);
    /**
     * Make a request to the Websets API
     * @param endpoint The endpoint path
     * @param method The HTTP method
     * @param data Optional request body data
     * @param params Optional query parameters
     * @returns The response JSON
     * @throws ExaError with API error details if the request fails
     */
    protected request<T = unknown>(endpoint: string, method?: string, data?: RequestBody$1, params?: QueryParams$1, headers?: Record<string, string>): Promise<T>;
    /**
     * Helper to build pagination parameters
     * @param pagination The pagination parameters
     * @returns QueryParams object with pagination parameters
     */
    protected buildPaginationParams(pagination?: PaginationParams): QueryParams$1;
}

interface components$1 {
    schemas: {
        /** Article */
        ArticleEntity: {
            /**
             * @default article
             * @constant
             */
            type: "article";
        };
        /** Company */
        CompanyEntity: {
            /**
             * @default company
             * @constant
             */
            type: "company";
        };
        CreateCriterionParameters: {
            /** @description The description of the criterion */
            description: string;
        };
        CreateEnrichmentParameters: {
            /** @description Provide a description of the enrichment task you want to perform to each Webset Item. */
            description: string;
            /**
             * @description Format of the enrichment response.
             *
             *     We automatically select the best format based on the description. If you want to explicitly specify the format, you can do so here.
             * @enum {string}
             */
            format?: CreateEnrichmentParametersFormat;
            /** @description Set of key-value pairs you want to associate with this object. */
            metadata?: {
                [key: string]: string;
            };
            /** @description When the format is options, the different options for the enrichment agent to choose from. */
            options?: {
                /** @description The label of the option */
                label: string;
            }[];
        };
        CreateImportParameters: {
            /** @description The number of records to import */
            count: number;
            /** @description When format is `csv`, these are the specific import parameters. */
            csv?: {
                /** @description Column containing the key identifier for the entity (e.g. URL, Name, etc.). If not provided, we will try to infer it from the file. */
                identifier?: number;
            };
            /** @description What type of entity the import contains (e.g. People, Companies, etc.), and thus should be attempted to be resolved as. */
            entity: components$1["schemas"]["CompanyEntity"] | components$1["schemas"]["PersonEntity"] | components$1["schemas"]["ArticleEntity"] | components$1["schemas"]["ResearchPaperEntity"] | components$1["schemas"]["CustomEntity"];
            /**
             * @description When the import is in CSV format, we expect a column containing the key identifier for the entity - for now URL. If not provided, import will fail to be processed.
             * @enum {string}
             */
            format: CreateImportParametersFormat;
            /** @description Set of key-value pairs you want to associate with this object. */
            metadata?: {
                [key: string]: string;
            };
            /** @description The size of the file in megabytes. Maximum size is 50 MB. */
            size: number;
            /** @description The title of the import */
            title?: string;
        };
        /** @description The response to a successful import. Includes the upload URL and the upload valid until date. */
        CreateImportResponse: {
            /** @description The number of entities in the import */
            count: number;
            /**
             * Format: date-time
             * @description When the import was created
             */
            createdAt: string;
            /** @description The type of entity the import contains. */
            entity: components$1["schemas"]["Entity"];
            /**
             * Format: date-time
             * @description When the import failed
             */
            failedAt: string | null;
            /** @description A human readable message of the import failure */
            failedMessage: string | null;
            /**
             * @description The reason the import failed
             * @enum {string|null}
             */
            failedReason: CreateImportResponseFailedReason;
            /**
             * @description The format of the import.
             * @enum {string}
             */
            format: CreateImportResponseFormat;
            /** @description The unique identifier for the Import */
            id: string;
            /** @description Set of key-value pairs you want to associate with this object. */
            metadata: {
                [key: string]: string;
            };
            /**
             * @description The type of object
             * @enum {string}
             */
            object: CreateImportResponseObject;
            /**
             * @description The status of the Import
             * @enum {string}
             */
            status: CreateImportResponseStatus;
            /** @description The title of the import */
            title: string;
            /**
             * Format: date-time
             * @description When the import was last updated
             */
            updatedAt: string;
            /** @description The URL to upload the file to */
            uploadUrl: string;
            /** @description The date and time until the upload URL is valid. The upload URL will be valid for 1 hour. */
            uploadValidUntil: string;
        };
        CreateMonitorParameters: {
            /** @description Behavior to perform when monitor runs */
            behavior: {
                /** @description Specify the search parameters for the Monitor.
                 *
                 *     By default, the search parameters (query, entity and criteria) from the last search are used when no parameters are provided. */
                config: {
                    /**
                     * @description The behaviour of the Search when it is added to a Webset.
                     * @default append
                     * @enum {string}
                     */
                    behavior: WebsetSearchBehavior;
                    /** @description The maximum number of results to find */
                    count: number;
                    /** @description The criteria to search for. By default, the criteria from the last search is used. */
                    criteria?: {
                        description: string;
                    }[];
                    /**
                     * Entity
                     * @description The entity to search for. By default, the entity from the last search/import is used.
                     */
                    entity?: components$1["schemas"]["Entity"];
                    /** @description The query to search for. By default, the query from the last search is used. */
                    query?: string;
                };
                /**
                 * @default search
                 * @constant
                 */
                type: "search";
            };
            /** @description How often the monitor will run */
            cadence: {
                /** @description Cron expression for monitor cadence (must be a valid Unix cron with 5 fields). The schedule must trigger at most once per day. */
                cron: string;
                /**
                 * @description IANA timezone (e.g., "America/New_York")
                 * @default Etc/UTC
                 */
                timezone: string;
            };
            metadata?: {
                [key: string]: string;
            };
            /** @description The id of the Webset */
            websetId: string;
        };
        CreateWebhookParameters: {
            /** @description The events to trigger the webhook */
            events: EventType[];
            /** @description Set of key-value pairs you want to associate with this object. */
            metadata?: {
                [key: string]: string;
            };
            /**
             * Format: uri
             * @description The URL to send the webhook to
             */
            url: string;
        };
        CreateWebsetParameters: {
            /** @description Add enrichments to extract additional data from found items.
             *
             *     Enrichments automatically search for and extract specific information (like contact details, funding data, employee counts, etc.) from each item added to your Webset. */
            enrichments?: components$1["schemas"]["CreateEnrichmentParameters"][];
            /** @description The external identifier for the webset.
             *
             *     You can use this to reference the Webset by your own internal identifiers. */
            externalId?: string;
            /** @description Import data from existing Websets and Imports into this Webset. */
            import?: {
                /** @description The ID of the source to search. */
                id: string;
                /** @enum {string} */
                source: CreateWebsetParametersImportSource;
            }[];
            /** @description Set of key-value pairs you want to associate with this object. */
            metadata?: {
                [key: string]: string;
            };
            /** @description Create initial search for the Webset. */
            search?: {
                /**
                 * @description Number of Items the Webset will attempt to find.
                 *
                 *     The actual number of Items found may be less than this number depending on the search complexity.
                 * @default 10
                 */
                count: number;
                /** @description Criteria every item is evaluated against.
                 *
                 *     It's not required to provide your own criteria, we automatically detect the criteria from all the information provided in the query. Only use this when you need more fine control. */
                criteria?: components$1["schemas"]["CreateCriterionParameters"][];
                /** @description Entity the Webset will return results for.
                 *
                 *     It is not required to provide it, we automatically detect the entity from all the information provided in the query. Only use this when you need more fine control. */
                entity?: components$1["schemas"]["Entity"];
                /** @description Sources (existing imports or websets) to exclude from search results. Any results found within these sources will be omitted to prevent finding them during search. */
                exclude?: {
                    /** @description The ID of the source to exclude. */
                    id: string;
                    /** @enum {string} */
                    source: CreateWebsetParametersSearchExcludeSource;
                }[];
                /** @description Natural language search query describing what you are looking for.
                 *
                 *     Be specific and descriptive about your requirements, characteristics, and any constraints that help narrow down the results.
                 *
                 *     Any URLs provided will be crawled and used as additional context for the search. */
                query: string;
                /** @description Whether to provide an estimate of how many total relevant results could exist for this search.
                 *     Result of the analysis will be available in the `recall` field within the search request. */
                recall?: boolean;
                /** @description Limit the search to specific sources (existing imports or websets). Any results found within these sources matching the search criteria will be included in the Webset. */
                scope?: {
                    /** @description The ID of the source to search. */
                    id: string;
                    relationship?: {
                        /** @description What the relationship of the entities you hope to find is relative to the entities contained in the provided source. */
                        definition: string;
                        limit: number;
                    };
                    /** @enum {string} */
                    source: CreateWebsetSearchParametersScopeSource;
                }[];
            };
        };
        CreateWebsetSearchParameters: {
            /**
             * @description How this search interacts with existing items in the Webset:
             *
             *     - **override**: Replace existing items and evaluate all items against new criteria
             *     - **append**: Add new items to existing ones, keeping items that match the new criteria
             * @default override
             */
            behavior: components$1["schemas"]["WebsetSearchBehavior"];
            /** @description Number of Items the Search will attempt to find.
             *
             *     The actual number of Items found may be less than this number depending on the query complexity. */
            count: number;
            /** @description Criteria every item is evaluated against.
             *
             *     It's not required to provide your own criteria, we automatically detect the criteria from all the information provided in the query. Only use this when you need more fine control. */
            criteria?: components$1["schemas"]["CreateCriterionParameters"][];
            /** @description Entity the search will return results for.
             *
             *     It is not required to provide it, we automatically detect the entity from all the information provided in the query. Only use this when you need more fine control. */
            entity?: components$1["schemas"]["Entity"];
            /** @description Sources (existing imports or websets) to exclude from search results. Any results found within these sources will be omitted to prevent finding them during search. */
            exclude?: {
                /** @description The ID of the source to exclude. */
                id: string;
                /** @enum {string} */
                source: CreateWebsetSearchParametersExcludeSource;
            }[];
            /** @description Set of key-value pairs you want to associate with this object. */
            metadata?: {
                [key: string]: string;
            };
            /** @description Natural language search query describing what you are looking for.
             *
             *     Be specific and descriptive about your requirements, characteristics, and any constraints that help narrow down the results.
             *
             *     Any URLs provided will be crawled and used as additional context for the search. */
            query: string;
            /** @description Whether to provide an estimate of how many total relevant results could exist for this search.
             *     Result of the analysis will be available in the `recall` field within the search request. */
            recall?: boolean;
            /** @description Limit the search to specific sources (existing imports). Any results found within these sources matching the search criteria will be included in the Webset. */
            scope?: {
                /** @description The ID of the source to search. */
                id: string;
                relationship?: {
                    /** @description What the relationship of the entities you hope to find is relative to the entities contained in the provided source. */
                    definition: string;
                    limit: number;
                };
                /** @enum {string} */
                source: CreateWebsetSearchParametersScopeSource;
            }[];
        };
        /** Custom */
        CustomEntity: {
            description: string;
            /**
             * @default custom
             * @constant
             */
            type: "custom";
        };
        EnrichmentResult: {
            /** @description The id of the Enrichment that generated the result */
            enrichmentId: string;
            format: components$1["schemas"]["WebsetEnrichmentFormat"];
            /**
             * @default enrichment_result
             * @constant
             */
            object: "enrichment_result";
            /** @description The reasoning for the result when an Agent is used. */
            reasoning: string | null;
            /** @description The references used to generate the result. */
            references: {
                /** @description The relevant snippet of the reference content */
                snippet: string | null;
                /** @description The title of the reference */
                title: string | null;
                /**
                 * Format: uri
                 * @description The URL of the reference
                 */
                url: string;
            }[];
            /** @description The result of the enrichment. */
            result: string[] | null;
            /**
             * @description The status of the enrichment result.
             * @enum {string}
             */
            status: EnrichmentResultStatus;
        };
        Entity: components$1["schemas"]["CompanyEntity"] | components$1["schemas"]["PersonEntity"] | components$1["schemas"]["ArticleEntity"] | components$1["schemas"]["ResearchPaperEntity"] | components$1["schemas"]["CustomEntity"];
        /** Event */
        Event: {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components$1["schemas"]["Webset"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.created
             * @constant
             */
            type: "webset.created";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components$1["schemas"]["Webset"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.deleted
             * @constant
             */
            type: "webset.deleted";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components$1["schemas"]["Webset"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.idle
             * @constant
             */
            type: "webset.idle";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components$1["schemas"]["Webset"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.paused
             * @constant
             */
            type: "webset.paused";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components$1["schemas"]["WebsetItem"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.item.created
             * @constant
             */
            type: "webset.item.created";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components$1["schemas"]["WebsetItem"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.item.enriched
             * @constant
             */
            type: "webset.item.enriched";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components$1["schemas"]["WebsetSearch"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.search.created
             * @constant
             */
            type: "webset.search.created";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components$1["schemas"]["WebsetSearch"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.search.updated
             * @constant
             */
            type: "webset.search.updated";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components$1["schemas"]["WebsetSearch"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.search.canceled
             * @constant
             */
            type: "webset.search.canceled";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components$1["schemas"]["WebsetSearch"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.search.completed
             * @constant
             */
            type: "webset.search.completed";
        };
        /** @enum {string} */
        EventType: EventType;
        GetWebsetResponse: components$1["schemas"]["Webset"] & {
            /** @description When expand query parameter contains `items`, this will contain the items in the webset */
            items?: components$1["schemas"]["WebsetItem"][];
        };
        Import: {
            /** @description The number of entities in the import */
            count: number;
            /**
             * Format: date-time
             * @description When the import was created
             */
            createdAt: string;
            /** @description The type of entity the import contains. */
            entity: components$1["schemas"]["Entity"];
            /**
             * Format: date-time
             * @description When the import failed
             */
            failedAt: string | null;
            /** @description A human readable message of the import failure */
            failedMessage: string | null;
            /**
             * @description The reason the import failed
             * @enum {string|null}
             */
            failedReason: ImportFailedReason;
            /**
             * @description The format of the import.
             * @enum {string}
             */
            format: ImportFormat;
            /** @description The unique identifier for the Import */
            id: string;
            /** @description Set of key-value pairs you want to associate with this object. */
            metadata: {
                [key: string]: string;
            };
            /**
             * @description The type of object
             * @enum {string}
             */
            object: ImportObject;
            /**
             * @description The status of the Import
             * @enum {string}
             */
            status: ImportStatus;
            /** @description The title of the import */
            title: string;
            /**
             * Format: date-time
             * @description When the import was last updated
             */
            updatedAt: string;
        };
        ListEventsResponse: {
            /** @description The list of events */
            data: components$1["schemas"]["Event"][];
            /** @description Whether there are more results to paginate through */
            hasMore: boolean;
            /** @description The cursor to paginate through the next set of results */
            nextCursor: string | null;
        };
        ListImportsResponse: {
            /** @description The list of imports */
            data: components$1["schemas"]["Import"][];
            /** @description Whether there are more results to paginate through */
            hasMore: boolean;
            /** @description The cursor to paginate through the next set of results */
            nextCursor: string | null;
        };
        ListMonitorRunsResponse: {
            /** @description The list of monitor runs */
            data: components$1["schemas"]["MonitorRun"][];
            /** @description Whether there are more results to paginate through */
            hasMore: boolean;
            /** @description The cursor to paginate through the next set of results */
            nextCursor: string | null;
        };
        ListMonitorsResponse: {
            /** @description The list of monitors */
            data: components$1["schemas"]["Monitor"][];
            /** @description Whether there are more results to paginate through */
            hasMore: boolean;
            /** @description The cursor to paginate through the next set of results */
            nextCursor: string | null;
        };
        ListWebhookAttemptsResponse: {
            /** @description The list of webhook attempts */
            data: components$1["schemas"]["WebhookAttempt"][];
            /** @description Whether there are more results to paginate through */
            hasMore: boolean;
            /** @description The cursor to paginate through the next set of results */
            nextCursor: string | null;
        };
        ListWebhooksResponse: {
            /** @description The list of webhooks */
            data: components$1["schemas"]["Webhook"][];
            /** @description Whether there are more results to paginate through */
            hasMore: boolean;
            /** @description The cursor to paginate through the next set of results */
            nextCursor: string | null;
        };
        ListWebsetItemResponse: {
            /** @description The list of webset items */
            data: components$1["schemas"]["WebsetItem"][];
            /** @description Whether there are more Items to paginate through */
            hasMore: boolean;
            /** @description The cursor to paginate through the next set of Items */
            nextCursor: string | null;
        };
        ListWebsetsResponse: {
            /** @description The list of websets */
            data: components$1["schemas"]["Webset"][];
            /** @description Whether there are more results to paginate through */
            hasMore: boolean;
            /** @description The cursor to paginate through the next set of results */
            nextCursor: string | null;
        };
        Monitor: {
            /** @description Behavior to perform when monitor runs */
            behavior: {
                /** @description Specify the search parameters for the Monitor.
                 *
                 *     By default, the search parameters (query, entity and criteria) from the last search are used when no parameters are provided. */
                config: {
                    /**
                     * @description The behaviour of the Search when it is added to a Webset.
                     * @default append
                     * @enum {string}
                     */
                    behavior: WebsetSearchBehavior;
                    /** @description The maximum number of results to find */
                    count: number;
                    /** @description The criteria to search for. By default, the criteria from the last search is used. */
                    criteria?: {
                        description: string;
                    }[];
                    /**
                     * Entity
                     * @description The entity to search for. By default, the entity from the last search/import is used.
                     */
                    entity?: components$1["schemas"]["Entity"];
                    /** @description The query to search for. By default, the query from the last search is used. */
                    query?: string;
                };
                /**
                 * @default search
                 * @constant
                 */
                type: "search";
            };
            /** @description How often the monitor will run */
            cadence: {
                /** @description Cron expression for monitor cadence (must be a valid Unix cron with 5 fields). The schedule must trigger at most once per day. */
                cron: string;
                /**
                 * @description IANA timezone (e.g., "America/New_York")
                 * @default Etc/UTC
                 */
                timezone: string;
            };
            /**
             * Format: date-time
             * @description When the monitor was created
             */
            createdAt: string;
            /** @description The unique identifier for the Monitor */
            id: string;
            /**
             * MonitorRun
             * @description The last run of the monitor
             */
            lastRun: components$1["schemas"]["MonitorRun"];
            /** @description Set of key-value pairs you want to associate with this object. */
            metadata: {
                [key: string]: string;
            };
            /**
             * Format: date-time
             * @description Date and time when the next run will occur in
             */
            nextRunAt: string | null;
            /**
             * @description The type of object
             * @enum {string}
             */
            object: MonitorObject;
            /**
             * @description The status of the Monitor
             * @enum {string}
             */
            status: MonitorStatus;
            /**
             * Format: date-time
             * @description When the monitor was last updated
             */
            updatedAt: string;
            /** @description The id of the Webset the Monitor belongs to */
            websetId: string;
        };
        MonitorBehavior: {
            /** @description Specify the search parameters for the Monitor.
             *
             *     By default, the search parameters (query, entity and criteria) from the last search are used when no parameters are provided. */
            config: {
                /**
                 * @description The behaviour of the Search when it is added to a Webset.
                 * @default append
                 * @enum {string}
                 */
                behavior: WebsetSearchBehavior;
                /** @description The maximum number of results to find */
                count: number;
                /** @description The criteria to search for. By default, the criteria from the last search is used. */
                criteria?: {
                    description: string;
                }[];
                /**
                 * Entity
                 * @description The entity to search for. By default, the entity from the last search/import is used.
                 */
                entity?: components$1["schemas"]["Entity"];
                /** @description The query to search for. By default, the query from the last search is used. */
                query?: string;
            };
            /**
             * @default search
             * @constant
             */
            type: "search";
        };
        MonitorCadence: {
            /** @description Cron expression for monitor cadence (must be a valid Unix cron with 5 fields). The schedule must trigger at most once per day. */
            cron: string;
            /**
             * @description IANA timezone (e.g., "America/New_York")
             * @default Etc/UTC
             */
            timezone: string;
        };
        MonitorRun: {
            /**
             * Format: date-time
             * @description When the run was canceled
             */
            canceledAt: string | null;
            /**
             * Format: date-time
             * @description When the run completed
             */
            completedAt: string | null;
            /**
             * Format: date-time
             * @description When the run was created
             */
            createdAt: string;
            /**
             * Format: date-time
             * @description When the run failed
             */
            failedAt: string | null;
            /** @description The reason the run failed */
            failedReason: string | null;
            /** @description The unique identifier for the Monitor Run */
            id: string;
            /** @description The monitor that the run is associated with */
            monitorId: string;
            /**
             * @description The type of object
             * @enum {string}
             */
            object: MonitorRunObject;
            /**
             * @description The status of the Monitor Run
             * @enum {string}
             */
            status: MonitorRunStatus;
            /**
             * @description The type of the Monitor Run
             * @enum {string}
             */
            type: MonitorRunType;
            /**
             * Format: date-time
             * @description When the run was last updated
             */
            updatedAt: string;
        };
        /** Person */
        PersonEntity: {
            /**
             * @default person
             * @constant
             */
            type: "person";
        };
        PreviewWebsetParameters: {
            /** @description Entity used to inform the decomposition.
             *
             *     It is not required to provide it, we automatically detect the entity from all the information provided in the query. Only use this when you need more fine control. */
            entity?: components$1["schemas"]["Entity"];
            /** @description Natural language search query describing what you are looking for.
             *
             *     Be specific and descriptive about your requirements, characteristics, and any constraints that help narrow down the results. */
            query: string;
        };
        PreviewWebsetResponse: {
            /** @description Detected enrichments from the query. */
            enrichments: {
                /** @description Description of the enrichment. */
                description: string;
                /**
                 * @description Format of the enrichment.
                 * @enum {string}
                 */
                format: PreviewWebsetResponseEnrichmentsFormat;
                /** @description When format is options, the options detected from the query. */
                options?: {
                    /** @description Label of the option. */
                    label: string;
                }[];
            }[];
            search: {
                /** @description Detected criteria from the query. */
                criteria: {
                    description: string;
                }[];
                /** @description Detected entity from the query. */
                entity: components$1["schemas"]["CompanyEntity"] | components$1["schemas"]["PersonEntity"] | components$1["schemas"]["ArticleEntity"] | components$1["schemas"]["ResearchPaperEntity"] | components$1["schemas"]["CustomEntity"];
            };
        };
        /** Research Paper */
        ResearchPaperEntity: {
            /**
             * @default research_paper
             * @constant
             */
            type: "research_paper";
        };
        UpdateImport: {
            metadata?: {
                [key: string]: string;
            };
            title?: string;
        };
        UpdateMonitor: {
            behavior?: components$1["schemas"]["MonitorBehavior"];
            cadence?: components$1["schemas"]["MonitorCadence"];
            metadata?: {
                [key: string]: string;
            };
            /**
             * @description The status of the monitor.
             * @enum {string}
             */
            status?: UpdateMonitorStatus;
        };
        UpdateWebhookParameters: {
            /** @description The events to trigger the webhook */
            events?: EventType[];
            /** @description Set of key-value pairs you want to associate with this object. */
            metadata?: {
                [key: string]: string;
            };
            /**
             * Format: uri
             * @description The URL to send the webhook to
             */
            url?: string;
        };
        UpdateWebsetRequest: {
            /** @description Set of key-value pairs you want to associate with this object. */
            metadata?: {
                [key: string]: string;
            } | null;
        };
        Webhook: {
            /**
             * Format: date-time
             * @description The date and time the webhook was created
             */
            createdAt: string;
            /** @description The events to trigger the webhook */
            events: EventType[];
            /** @description The unique identifier for the webhook */
            id: string;
            /**
             * @description The metadata of the webhook
             * @default {}
             */
            metadata: {
                [key: string]: string;
            };
            /**
             * @default webhook
             * @constant
             */
            object: "webhook";
            /** @description The secret to verify the webhook signature. Only returned on Webhook creation. */
            secret: string | null;
            /**
             * WebhookStatus
             * @description The status of the webhook
             * @enum {string}
             */
            status: WebhookStatus;
            /**
             * Format: date-time
             * @description The date and time the webhook was last updated
             */
            updatedAt: string;
            /**
             * Format: uri
             * @description The URL to send the webhook to
             */
            url: string;
        };
        WebhookAttempt: {
            /** @description The attempt number of the webhook */
            attempt: number;
            /**
             * Format: date-time
             * @description The date and time the webhook attempt was made
             */
            attemptedAt: string;
            /** @description The unique identifier for the event */
            eventId: string;
            /**
             * @description The type of event
             * @enum {string}
             */
            eventType: WebhookAttemptEventType;
            /** @description The unique identifier for the webhook attempt */
            id: string;
            /**
             * @default webhook_attempt
             * @constant
             */
            object: "webhook_attempt";
            /** @description The body of the response */
            responseBody: string | null;
            /** @description The headers of the response */
            responseHeaders: {
                [key: string]: string;
            };
            /** @description The status code of the response */
            responseStatusCode: number;
            /** @description Whether the attempt was successful */
            successful: boolean;
            /** @description The URL that was used during the attempt */
            url: string;
            /** @description The unique identifier for the webhook */
            webhookId: string;
        };
        Webset: {
            /**
             * Format: date-time
             * @description The date and time the webset was created
             */
            createdAt: string;
            /** @description The Enrichments to apply to the Webset Items. */
            enrichments: components$1["schemas"]["WebsetEnrichment"][];
            /** @description The external identifier for the webset */
            externalId: string | null;
            /** @description The unique identifier for the webset */
            id: string;
            /** @description Imports that have been performed on the webset. */
            imports: components$1["schemas"]["Import"][];
            /**
             * @description Set of key-value pairs you want to associate with this object.
             * @default {}
             */
            metadata: {
                [key: string]: string;
            };
            /** @description The Monitors for the Webset. */
            monitors: components$1["schemas"]["Monitor"][];
            /**
             * @default webset
             * @constant
             */
            object: "webset";
            /** @description The searches that have been performed on the webset. */
            searches: components$1["schemas"]["WebsetSearch"][];
            /**
             * WebsetStatus
             * @description The status of the webset
             * @enum {string}
             */
            status: WebsetStatus;
            /** @description The Streams for the Webset. */
            streams: unknown[];
            /** @description The title of the webset */
            title: string | null;
            /**
             * Format: date-time
             * @description The date and time the webset was updated
             */
            updatedAt: string;
        };
        WebsetEnrichment: {
            /**
             * Format: date-time
             * @description The date and time the enrichment was created
             */
            createdAt: string;
            /** @description The description of the enrichment task provided during the creation of the enrichment. */
            description: string;
            /** @description The format of the enrichment response. */
            format: components$1["schemas"]["WebsetEnrichmentFormat"];
            /** @description The unique identifier for the enrichment */
            id: string;
            /** @description The instructions for the enrichment Agent.
             *
             *     This will be automatically generated based on the description and format. */
            instructions: string | null;
            /**
             * @description The metadata of the enrichment
             * @default {}
             */
            metadata: {
                [key: string]: string;
            };
            /**
             * @default webset_enrichment
             * @constant
             */
            object: "webset_enrichment";
            /**
             * WebsetEnrichmentOptions
             * @description When the format is options, the different options for the enrichment agent to choose from.
             */
            options: {
                /** @description The label of the option */
                label: string;
            }[] | null;
            /**
             * WebsetEnrichmentStatus
             * @description The status of the enrichment
             * @enum {string}
             */
            status: WebsetEnrichmentStatus;
            /** @description The title of the enrichment.
             *
             *     This will be automatically generated based on the description and format. */
            title: string | null;
            /**
             * Format: date-time
             * @description The date and time the enrichment was updated
             */
            updatedAt: string;
            /** @description The unique identifier for the Webset this enrichment belongs to. */
            websetId: string;
        };
        /** @enum {string} */
        WebsetEnrichmentFormat: WebsetEnrichmentFormat;
        WebsetItem: {
            /**
             * Format: date-time
             * @description The date and time the item was created
             */
            createdAt: string;
            /** @description The enrichments results of the Webset item */
            enrichments: components$1["schemas"]["EnrichmentResult"][] | null;
            /** @description The criteria evaluations of the item */
            evaluations: components$1["schemas"]["WebsetItemEvaluation"][];
            /** @description The unique identifier for the Webset Item */
            id: string;
            /**
             * @default webset_item
             * @constant
             */
            object: "webset_item";
            /** @description The properties of the Item */
            properties: components$1["schemas"]["WebsetItemPersonProperties"] | components$1["schemas"]["WebsetItemCompanyProperties"] | components$1["schemas"]["WebsetItemArticleProperties"] | components$1["schemas"]["WebsetItemResearchPaperProperties"] | components$1["schemas"]["WebsetItemCustomProperties"];
            /**
             * @description The source of the Item
             * @enum {string}
             */
            source: WebsetItemSource;
            /** @description The unique identifier for the source */
            sourceId: string;
            /**
             * Format: date-time
             * @description The date and time the item was last updated
             */
            updatedAt: string;
            /** @description The unique identifier for the Webset this Item belongs to. */
            websetId: string;
        };
        WebsetItemArticleProperties: {
            /** WebsetItemArticlePropertiesFields */
            article: {
                /** @description The author(s) of the article */
                author: string | null;
                /** @description The date and time the article was published */
                publishedAt: string | null;
                /** @description The title of the article */
                title: string | null;
            };
            /** @description The text content for the article */
            content: string | null;
            /** @description Short description of the relevance of the article */
            description: string;
            /**
             * @default article
             * @constant
             */
            type: "article";
            /**
             * Format: uri
             * @description The URL of the article
             */
            url: string;
        };
        WebsetItemCompanyProperties: {
            /** WebsetItemCompanyPropertiesFields */
            company: {
                /** @description A short description of the company */
                about: string | null;
                /** @description The number of employees of the company */
                employees: number | null;
                /** @description The industry of the company */
                industry: string | null;
                /** @description The main location of the company */
                location: string | null;
                /**
                 * Format: uri
                 * @description The logo URL of the company
                 */
                logoUrl: string | null;
                /** @description The name of the company */
                name: string;
            };
            /** @description The text content of the company website */
            content: string | null;
            /** @description Short description of the relevance of the company */
            description: string;
            /**
             * @default company
             * @constant
             */
            type: "company";
            /**
             * Format: uri
             * @description The URL of the company website
             */
            url: string;
        };
        WebsetItemCustomProperties: {
            /** @description The text content of the Item */
            content: string | null;
            /** WebsetItemCustomPropertiesFields */
            custom: {
                /** @description The author(s) of the website */
                author: string | null;
                /** @description The date and time the website was published */
                publishedAt: string | null;
                /** @description The title of the website */
                title: string | null;
            };
            /** @description Short description of the Item */
            description: string;
            /**
             * @default custom
             * @constant
             */
            type: "custom";
            /**
             * Format: uri
             * @description The URL of the Item
             */
            url: string;
        };
        WebsetItemEvaluation: {
            /** @description The description of the criterion */
            criterion: string;
            /** @description The reasoning for the result of the evaluation */
            reasoning: string;
            /**
             * @description The references used to generate the result.
             * @default []
             */
            references: {
                /** @description The relevant snippet of the reference content */
                snippet: string | null;
                /** @description The title of the reference */
                title: string | null;
                /**
                 * Format: uri
                 * @description The URL of the reference
                 */
                url: string;
            }[];
            /**
             * @description The satisfaction of the criterion
             * @enum {string}
             */
            satisfied: WebsetItemEvaluationSatisfied;
        };
        WebsetItemPersonProperties: {
            /** @description Short description of the relevance of the person */
            description: string;
            /** WebsetItemPersonPropertiesFields */
            person: {
                /** WebsetItemPersonCompanyPropertiesFields */
                company: {
                    /** @description The location the person is working at the company */
                    location: string | null;
                    /** @description The name of the company */
                    name: string;
                } | null;
                /** @description The location of the person */
                location: string | null;
                /** @description The name of the person */
                name: string;
                /**
                 * Format: uri
                 * @description The image URL of the person
                 */
                pictureUrl: string | null;
                /** @description The current work position of the person */
                position: string | null;
            };
            /**
             * @default person
             * @constant
             */
            type: "person";
            /**
             * Format: uri
             * @description The URL of the person profile
             */
            url: string;
        };
        WebsetItemResearchPaperProperties: {
            /** @description The text content of the research paper */
            content: string | null;
            /** @description Short description of the relevance of the research paper */
            description: string;
            /** WebsetItemResearchPaperPropertiesFields */
            researchPaper: {
                /** @description The author(s) of the research paper */
                author: string | null;
                /** @description The date and time the research paper was published */
                publishedAt: string | null;
                /** @description The title of the research paper */
                title: string | null;
            };
            /**
             * @default research_paper
             * @constant
             */
            type: "research_paper";
            /**
             * Format: uri
             * @description The URL of the research paper
             */
            url: string;
        };
        WebsetSearch: {
            /**
             * @description The behavior of the search when it is added to a Webset.
             *
             *     - `override`: the search will replace the existing Items found in the Webset and evaluate them against the new criteria. Any Items that don't match the new criteria will be discarded.
             *     - `append`: the search will add the new Items found to the existing Webset. Any Items that don't match the new criteria will be discarded.
             * @default override
             */
            behavior: components$1["schemas"]["WebsetSearchBehavior"];
            /**
             * Format: date-time
             * @description The date and time the search was canceled
             */
            canceledAt: string | null;
            /** @description The reason the search was canceled */
            canceledReason: components$1["schemas"]["WebsetSearchCanceledReason"];
            /** @description The number of results the search will attempt to find. The actual number of results may be less than this number depending on the search complexity. */
            count: number;
            /**
             * Format: date-time
             * @description The date and time the search was created
             */
            createdAt: string;
            /** @description The criteria the search will use to evaluate the results. If not provided, we will automatically generate them for you. */
            criteria: {
                /** @description The description of the criterion */
                description: string;
                /** @description Value between 0 and 100 representing the percentage of results that meet the criterion. */
                successRate: number;
            }[];
            /** @description The entity the search will return results for.
             *
             *     When no entity is provided during creation, we will automatically select the best entity based on the query. */
            entity: components$1["schemas"]["Entity"];
            /** @description Sources (existing imports or websets) used to omit certain results to be found during the search. */
            exclude: {
                id: string;
                /** @enum {string} */
                source: WebsetSearchExcludeSource;
            }[];
            /** @description The unique identifier for the search */
            id: string;
            /**
             * @description Set of key-value pairs you want to associate with this object.
             * @default {}
             */
            metadata: {
                [key: string]: string;
            };
            /**
             * @default webset_search
             * @constant
             */
            object: "webset_search";
            /** @description The progress of the search */
            progress: {
                /** @description The number of results analyzed so far */
                analyzed: number;
                /** @description The completion percentage of the search */
                completion: number;
                /** @description The number of results found so far */
                found: number;
                /** @description The estimated time remaining in seconds, null if unknown */
                timeLeft: number | null;
            };
            /** @description The query used to create the search. */
            query: string;
            /** @description Recall metrics for the search, null if not yet computed or requested. */
            recall: {
                expected: {
                    bounds: {
                        /** @description The maximum estimated total number of potential matches */
                        max: number;
                        /** @description The minimum estimated total number of potential matches */
                        min: number;
                    };
                    /**
                     * @description The confidence in the estimate
                     * @enum {string}
                     */
                    confidence: WebsetSearchRecallExpectedConfidence;
                    /** @description The estimated total number of potential matches */
                    total: number;
                };
                /** @description The reasoning for the estimate */
                reasoning: string;
            } | null;
            /** @description The scope of the search. By default, there is no scope - thus searching the web.
             *
             *     If provided during creation, the search will only be performed on the sources provided. */
            scope: {
                id: string;
                /**
                 * @default import
                 * @enum {string}
                 */
                source: ScopeSourceType;
            }[];
            /**
             * WebsetSearchStatus
             * @description The status of the search
             * @enum {string}
             */
            status: WebsetSearchStatus;
            /**
             * Format: date-time
             * @description The date and time the search was updated
             */
            updatedAt: string;
            /** @description The unique identifier for the Webset this search belongs to */
            websetId: string;
        };
        /** @enum {string} */
        WebsetSearchBehavior: WebsetSearchBehavior;
        /** @enum {string} */
        WebsetSearchCanceledReason: WebsetSearchCanceledReason;
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
type ArticleEntity = components$1["schemas"]["ArticleEntity"];
type CompanyEntity = components$1["schemas"]["CompanyEntity"];
type CreateCriterionParameters = components$1["schemas"]["CreateCriterionParameters"];
type CreateEnrichmentParameters = components$1["schemas"]["CreateEnrichmentParameters"];
type CreateImportParameters = components$1["schemas"]["CreateImportParameters"];
type CreateImportResponse = components$1["schemas"]["CreateImportResponse"];
type CreateMonitorParameters = components$1["schemas"]["CreateMonitorParameters"];
type CreateWebhookParameters = components$1["schemas"]["CreateWebhookParameters"];
type CreateWebsetParameters = components$1["schemas"]["CreateWebsetParameters"];
type CreateWebsetSearchParameters = components$1["schemas"]["CreateWebsetSearchParameters"];
type CustomEntity = components$1["schemas"]["CustomEntity"];
type EnrichmentResult = components$1["schemas"]["EnrichmentResult"];
type Entity = components$1["schemas"]["Entity"];
type Event = components$1["schemas"]["Event"];
type GetWebsetResponse = components$1["schemas"]["GetWebsetResponse"];
type Import = components$1["schemas"]["Import"];
type ListEventsResponse = components$1["schemas"]["ListEventsResponse"];
type ListImportsResponse = components$1["schemas"]["ListImportsResponse"];
type ListMonitorRunsResponse = components$1["schemas"]["ListMonitorRunsResponse"];
type ListMonitorsResponse = components$1["schemas"]["ListMonitorsResponse"];
type ListWebhookAttemptsResponse = components$1["schemas"]["ListWebhookAttemptsResponse"];
type ListWebhooksResponse = components$1["schemas"]["ListWebhooksResponse"];
type ListWebsetItemResponse = components$1["schemas"]["ListWebsetItemResponse"];
type ListWebsetsResponse = components$1["schemas"]["ListWebsetsResponse"];
type Monitor = components$1["schemas"]["Monitor"];
type MonitorBehavior = components$1["schemas"]["MonitorBehavior"];
type MonitorCadence = components$1["schemas"]["MonitorCadence"];
type MonitorRun = components$1["schemas"]["MonitorRun"];
type PersonEntity = components$1["schemas"]["PersonEntity"];
type PreviewWebsetParameters = components$1["schemas"]["PreviewWebsetParameters"];
type PreviewWebsetResponse = components$1["schemas"]["PreviewWebsetResponse"];
type ResearchPaperEntity = components$1["schemas"]["ResearchPaperEntity"];
type UpdateImport = components$1["schemas"]["UpdateImport"];
type UpdateMonitor = components$1["schemas"]["UpdateMonitor"];
type UpdateWebhookParameters = components$1["schemas"]["UpdateWebhookParameters"];
type UpdateWebsetRequest = components$1["schemas"]["UpdateWebsetRequest"];
type Webhook = components$1["schemas"]["Webhook"];
type WebhookAttempt = components$1["schemas"]["WebhookAttempt"];
type Webset = components$1["schemas"]["Webset"];
type WebsetEnrichment = components$1["schemas"]["WebsetEnrichment"];
type WebsetItem = components$1["schemas"]["WebsetItem"];
type WebsetItemArticleProperties = components$1["schemas"]["WebsetItemArticleProperties"];
type WebsetItemCompanyProperties = components$1["schemas"]["WebsetItemCompanyProperties"];
type WebsetItemCustomProperties = components$1["schemas"]["WebsetItemCustomProperties"];
type WebsetItemEvaluation = components$1["schemas"]["WebsetItemEvaluation"];
type WebsetItemPersonProperties = components$1["schemas"]["WebsetItemPersonProperties"];
type WebsetItemResearchPaperProperties = components$1["schemas"]["WebsetItemResearchPaperProperties"];
type WebsetSearch = components$1["schemas"]["WebsetSearch"];
declare enum CreateEnrichmentParametersFormat {
    text = "text",
    date = "date",
    number = "number",
    options = "options",
    email = "email",
    phone = "phone"
}
declare enum CreateImportParametersFormat {
    csv = "csv"
}
declare enum CreateImportResponseFailedReason {
    invalid_format = "invalid_format",
    invalid_file_content = "invalid_file_content",
    missing_identifier = "missing_identifier"
}
declare enum CreateImportResponseFormat {
    csv = "csv",
    webset = "webset"
}
declare enum CreateImportResponseObject {
    import = "import"
}
declare enum CreateImportResponseStatus {
    pending = "pending",
    processing = "processing",
    completed = "completed",
    failed = "failed"
}
declare enum CreateWebsetParametersImportSource {
    import = "import",
    webset = "webset"
}
declare enum CreateWebsetParametersSearchExcludeSource {
    import = "import",
    webset = "webset"
}
declare enum ScopeSourceType {
    import = "import",
    webset = "webset"
}
declare enum CreateWebsetSearchParametersExcludeSource {
    import = "import",
    webset = "webset"
}
declare enum CreateWebsetSearchParametersScopeSource {
    import = "import",
    webset = "webset"
}
declare enum EnrichmentResultStatus {
    pending = "pending",
    completed = "completed",
    canceled = "canceled"
}
declare enum EventType {
    webset_created = "webset.created",
    webset_deleted = "webset.deleted",
    webset_paused = "webset.paused",
    webset_idle = "webset.idle",
    webset_search_created = "webset.search.created",
    webset_search_canceled = "webset.search.canceled",
    webset_search_completed = "webset.search.completed",
    webset_search_updated = "webset.search.updated",
    import_created = "import.created",
    import_completed = "import.completed",
    import_processing = "import.processing",
    webset_item_created = "webset.item.created",
    webset_item_enriched = "webset.item.enriched",
    webset_export_created = "webset.export.created",
    webset_export_completed = "webset.export.completed"
}
declare enum ImportFailedReason {
    invalid_format = "invalid_format",
    invalid_file_content = "invalid_file_content",
    missing_identifier = "missing_identifier"
}
declare enum ImportFormat {
    csv = "csv",
    webset = "webset"
}
declare enum ImportObject {
    import = "import"
}
declare enum ImportStatus {
    pending = "pending",
    processing = "processing",
    completed = "completed",
    failed = "failed"
}
declare enum MonitorObject {
    monitor = "monitor"
}
declare enum MonitorStatus {
    enabled = "enabled",
    disabled = "disabled"
}
declare enum MonitorRunObject {
    monitor_run = "monitor_run"
}
declare enum MonitorRunStatus {
    created = "created",
    running = "running",
    completed = "completed",
    canceled = "canceled",
    failed = "failed"
}
declare enum MonitorRunType {
    search = "search",
    refresh = "refresh"
}
declare enum PreviewWebsetResponseEnrichmentsFormat {
    text = "text",
    date = "date",
    number = "number",
    options = "options",
    email = "email",
    phone = "phone"
}
declare enum UpdateMonitorStatus {
    enabled = "enabled",
    disabled = "disabled"
}
declare enum WebhookStatus {
    active = "active",
    inactive = "inactive"
}
declare enum WebhookAttemptEventType {
    webset_created = "webset.created",
    webset_deleted = "webset.deleted",
    webset_paused = "webset.paused",
    webset_idle = "webset.idle",
    webset_search_created = "webset.search.created",
    webset_search_canceled = "webset.search.canceled",
    webset_search_completed = "webset.search.completed",
    webset_search_updated = "webset.search.updated",
    import_created = "import.created",
    import_completed = "import.completed",
    import_processing = "import.processing",
    webset_item_created = "webset.item.created",
    webset_item_enriched = "webset.item.enriched",
    webset_export_created = "webset.export.created",
    webset_export_completed = "webset.export.completed"
}
declare enum WebsetStatus {
    idle = "idle",
    pending = "pending",
    running = "running",
    paused = "paused"
}
declare enum WebsetEnrichmentStatus {
    pending = "pending",
    canceled = "canceled",
    completed = "completed"
}
declare enum WebsetEnrichmentFormat {
    text = "text",
    date = "date",
    number = "number",
    options = "options",
    email = "email",
    phone = "phone"
}
declare enum WebsetItemSource {
    search = "search",
    import = "import"
}
declare enum WebsetItemEvaluationSatisfied {
    yes = "yes",
    no = "no",
    unclear = "unclear"
}
declare enum WebsetSearchExcludeSource {
    import = "import",
    webset = "webset"
}
declare enum WebsetSearchRecallExpectedConfidence {
    high = "high",
    medium = "medium",
    low = "low"
}
declare enum WebsetSearchStatus {
    created = "created",
    pending = "pending",
    running = "running",
    completed = "completed",
    canceled = "canceled"
}
declare enum WebsetSearchBehavior {
    override = "override",
    append = "append"
}
declare enum WebsetSearchCanceledReason {
    webset_deleted = "webset_deleted",
    webset_canceled = "webset_canceled"
}

/**
 * Client for managing Webset Enrichments
 */

/**
 * Client for managing Webset Enrichments
 */
declare class WebsetEnrichmentsClient extends WebsetsBaseClient {
    /**
     * Create an Enrichment for a Webset
     * @param websetId The ID of the Webset
     * @param params The enrichment parameters
     * @returns The created Webset Enrichment
     */
    create(websetId: string, params: CreateEnrichmentParameters): Promise<WebsetEnrichment>;
    /**
     * Get an Enrichment by ID
     * @param websetId The ID of the Webset
     * @param id The ID of the Enrichment
     * @returns The Webset Enrichment
     */
    get(websetId: string, id: string): Promise<WebsetEnrichment>;
    /**
     * Delete an Enrichment
     * @param websetId The ID of the Webset
     * @param id The ID of the Enrichment
     * @returns The deleted Webset Enrichment
     */
    delete(websetId: string, id: string): Promise<WebsetEnrichment>;
    /**
     * Cancel a running Enrichment
     * @param websetId The ID of the Webset
     * @param id The ID of the Enrichment
     * @returns The canceled Webset Enrichment
     */
    cancel(websetId: string, id: string): Promise<WebsetEnrichment>;
}

/**
 * Options for listing Events
 */
interface ListEventsOptions {
    /**
     * The cursor to paginate through the results
     */
    cursor?: string;
    /**
     * The number of results to return
     */
    limit?: number;
    /**
     * The types of events to filter by
     */
    types?: EventType[];
}
/**
 * Client for managing Events
 */
declare class EventsClient extends WebsetsBaseClient {
    /**
     * Initialize a new Events client
     * @param client The Exa client instance
     */
    constructor(client: Exa);
    /**
     * List all Events
     * @param options Optional filtering and pagination options
     * @returns The list of Events
     */
    list(options?: ListEventsOptions): Promise<ListEventsResponse>;
    /**
     * Get an Event by ID
     * @param id The ID of the Event
     * @returns The Event
     */
    get(id: string): Promise<Event>;
}

/**
 * Options for waiting until import completion
 */
interface WaitUntilCompletedOptions {
    /**
     * Maximum time to wait in milliseconds (default: 5 minutes)
     */
    timeout?: number;
    /**
     * How often to poll for status in milliseconds (default: 2 seconds)
     */
    pollInterval?: number;
    /**
     * Callback function called on each poll with the current status
     */
    onPoll?: (status: ImportStatus) => void;
}
/**
 * Parameters for creating an import with CSV data
 */
interface CreateImportWithCsvParameters {
    /**
     * Title of the import
     */
    title: string;
    /**
     * Entity type and configuration
     */
    entity: CreateImportParameters["entity"];
    /**
     * Optional metadata
     */
    metadata?: CreateImportParameters["metadata"];
    /**
     * Optional CSV-specific parameters
     */
    csv?: CreateImportParameters["csv"];
}
/**
 * CSV data input - can be raw data or buffer
 */
type CsvDataInput = string | Buffer;
/**
 * Client for managing Imports
 */
declare class ImportsClient extends WebsetsBaseClient {
    /**
     * Create a new Import (basic version - returns upload URL)
     * @param params The import creation parameters
     * @returns The created Import response with upload URL
     */
    create(params: CreateImportParameters): Promise<CreateImportResponse>;
    /**
     * Create a new Import with CSV data (handles upload)
     * @param params The import creation parameters (without size/count - calculated automatically)
     * @param csv CSV data as string or Buffer
     * @returns The Import after upload (not waited for completion)
     */
    create(params: CreateImportWithCsvParameters, csv: CsvDataInput): Promise<Import>;
    /**
     * Get an Import by ID
     * @param id The ID of the Import
     * @returns The Import
     */
    get(id: string): Promise<Import>;
    /**
     * List all Imports
     * @param options Pagination options
     * @returns The list of Imports
     */
    list(options?: PaginationParams): Promise<ListImportsResponse>;
    /**
     * Update an Import
     * @param id The ID of the Import
     * @param params The import update parameters
     * @returns The updated Import
     */
    update(id: string, params: UpdateImport): Promise<Import>;
    /**
     * Delete an Import
     * @param id The ID of the Import
     * @returns The deleted Import
     */
    delete(id: string): Promise<Import>;
    /**
     * Wait until an Import is completed or failed
     * @param id The ID of the Import
     * @param options Configuration options for timeout and polling
     * @returns The Import once it reaches a final state (completed or failed)
     * @throws Error if the Import does not complete within the timeout or fails
     */
    waitUntilCompleted(id: string, options?: WaitUntilCompletedOptions): Promise<Import>;
}

/**
 * Client for managing Webset Items
 */

/**
 * Options for listing webset items
 */
interface ListWebsetItemsOptions extends PaginationParams {
    /**
     * The id of the source to filter items by
     */
    sourceId?: string;
}
/**
 * Client for managing Webset Items
 */
declare class WebsetItemsClient extends WebsetsBaseClient {
    /**
     * List all Items for a Webset
     * @param websetId The ID of the Webset
     * @param params - Optional pagination and filtering parameters
     * @returns A promise that resolves with the list of Items
     */
    list(websetId: string, params?: ListWebsetItemsOptions): Promise<ListWebsetItemResponse>;
    /**
     * Iterate through all Items in a Webset, handling pagination automatically
     * @param websetId The ID of the Webset
     * @param options Pagination options
     * @returns Async generator of Webset Items
     */
    listAll(websetId: string, options?: ListWebsetItemsOptions): AsyncGenerator<WebsetItem>;
    /**
     * Collect all items from a Webset into an array
     * @param websetId The ID of the Webset
     * @param options Pagination options
     * @returns Promise resolving to an array of all Webset Items
     */
    getAll(websetId: string, options?: ListWebsetItemsOptions): Promise<WebsetItem[]>;
    /**
     * Get an Item by ID
     * @param websetId The ID of the Webset
     * @param id The ID of the Item
     * @returns The Webset Item
     */
    get(websetId: string, id: string): Promise<WebsetItem>;
    /**
     * Delete an Item
     * @param websetId The ID of the Webset
     * @param id The ID of the Item
     * @returns The deleted Webset Item
     */
    delete(websetId: string, id: string): Promise<WebsetItem>;
}

/**
 * Client for managing Webset Monitors
 */

/**
 * Options for listing monitors
 */
interface ListMonitorsOptions extends PaginationParams {
    /**
     * The id of the Webset to list monitors for
     */
    websetId?: string;
}
/**
 * Client for managing Monitor Runs
 */
declare class WebsetMonitorRunsClient extends WebsetsBaseClient {
    /**
     * List all runs for a Monitor
     * @param monitorId The ID of the Monitor
     * @param options Pagination options
     * @returns The list of Monitor runs
     */
    list(monitorId: string, options?: PaginationParams): Promise<ListMonitorRunsResponse>;
    /**
     * Get a specific Monitor run
     * @param monitorId The ID of the Monitor
     * @param runId The ID of the Monitor run
     * @returns The Monitor run
     */
    get(monitorId: string, runId: string): Promise<MonitorRun>;
}
/**
 * Client for managing Webset Monitors
 */
declare class WebsetMonitorsClient extends WebsetsBaseClient {
    /**
     * Client for managing Monitor Runs
     */
    runs: WebsetMonitorRunsClient;
    constructor(client: Exa);
    /**
     * Create a Monitor
     * @param params The monitor parameters
     * @returns The created Monitor
     */
    create(params: CreateMonitorParameters): Promise<Monitor>;
    /**
     * Get a Monitor by ID
     * @param id The ID of the Monitor
     * @returns The Monitor
     */
    get(id: string): Promise<Monitor>;
    /**
     * List all Monitors
     * @param options Pagination and filtering options
     * @returns The list of Monitors
     */
    list(options?: ListMonitorsOptions): Promise<ListMonitorsResponse>;
    /**
     * Update a Monitor
     * @param id The ID of the Monitor
     * @param params The monitor update parameters (status, metadata)
     * @returns The updated Monitor
     */
    update(id: string, params: UpdateMonitor): Promise<Monitor>;
    /**
     * Delete a Monitor
     * @param id The ID of the Monitor
     * @returns The deleted Monitor
     */
    delete(id: string): Promise<Monitor>;
}

/**
 * Client for managing Webset Webhooks
 */

/**
 * Options for listing webhooks (only pagination is supported by API)
 */
interface ListWebhooksOptions extends PaginationParams {
}
/**
 * Options for listing webhook attempts
 */
interface ListWebhookAttemptsOptions extends PaginationParams {
    /**
     * The type of event to filter by
     */
    eventType?: EventType;
    /**
     * Filter attempts by their success status
     */
    successful?: boolean;
}
/**
 * Client for managing Webset Webhooks
 */
declare class WebsetWebhooksClient extends WebsetsBaseClient {
    /**
     * Create a Webhook
     * @param params The webhook parameters
     * @returns The created Webhook
     */
    create(params: CreateWebhookParameters): Promise<Webhook>;
    /**
     * Get a Webhook by ID
     * @param id The ID of the Webhook
     * @returns The Webhook
     */
    get(id: string): Promise<Webhook>;
    /**
     * List all Webhooks
     * @param options Pagination options
     * @returns The list of Webhooks
     */
    list(options?: ListWebhooksOptions): Promise<ListWebhooksResponse>;
    /**
     * Iterate through all Webhooks, handling pagination automatically
     * @param options Pagination options
     * @returns Async generator of Webhooks
     */
    listAll(options?: ListWebhooksOptions): AsyncGenerator<Webhook>;
    /**
     * Collect all Webhooks into an array
     * @param options Pagination options
     * @returns Promise resolving to an array of all Webhooks
     */
    getAll(options?: ListWebhooksOptions): Promise<Webhook[]>;
    /**
     * Update a Webhook
     * @param id The ID of the Webhook
     * @param params The webhook update parameters (events, metadata, url)
     * @returns The updated Webhook
     */
    update(id: string, params: UpdateWebhookParameters): Promise<Webhook>;
    /**
     * Delete a Webhook
     * @param id The ID of the Webhook
     * @returns The deleted Webhook
     */
    delete(id: string): Promise<Webhook>;
    /**
     * List all attempts for a Webhook
     * @param id The ID of the Webhook
     * @param options Pagination and filtering options
     * @returns The list of Webhook attempts
     */
    listAttempts(id: string, options?: ListWebhookAttemptsOptions): Promise<ListWebhookAttemptsResponse>;
    /**
     * Iterate through all attempts for a Webhook, handling pagination automatically
     * @param id The ID of the Webhook
     * @param options Pagination and filtering options
     * @returns Async generator of Webhook attempts
     */
    listAllAttempts(id: string, options?: ListWebhookAttemptsOptions): AsyncGenerator<WebhookAttempt>;
    /**
     * Collect all attempts for a Webhook into an array
     * @param id The ID of the Webhook
     * @param options Pagination and filtering options
     * @returns Promise resolving to an array of all Webhook attempts
     */
    getAllAttempts(id: string, options?: ListWebhookAttemptsOptions): Promise<WebhookAttempt[]>;
}

/**
 * Websets API client
 */

type WebsetHeadersLike = {
    "x-exa-websets-priority"?: "low" | "medium" | "high";
} & Record<string, string>;

/**
 * Client for managing Webset Searches
 */

/**
 * Client for managing Webset Searches
 */
declare class WebsetSearchesClient extends WebsetsBaseClient {
    /**
     * Create a new Search for the Webset
     * @param websetId The ID of the Webset
     * @param params The search parameters
     * @returns The created Webset Search
     */
    create(websetId: string, params: CreateWebsetSearchParameters, options?: {
        headers?: WebsetHeadersLike;
    }): Promise<WebsetSearch>;
    /**
     * Get a Search by ID
     * @param websetId The ID of the Webset
     * @param id The ID of the Search
     * @returns The Webset Search
     */
    get(websetId: string, id: string): Promise<WebsetSearch>;
    /**
     * Cancel a running Search
     * @param websetId The ID of the Webset
     * @param id The ID of the Search
     * @returns The canceled Webset Search
     */
    cancel(websetId: string, id: string): Promise<WebsetSearch>;
}

/**
 * Main client for Websets API
 */

/**
 * Options for listing Websets (API only supports pagination)
 */
interface ListWebsetsOptions extends PaginationParams {
}
/**
 * Client for managing Websets
 */
declare class WebsetsClient extends WebsetsBaseClient {
    /**
     * Client for managing Events
     */
    events: EventsClient;
    /**
     * Client for managing Imports
     */
    imports: ImportsClient;
    /**
     * Client for managing Webset Items
     */
    items: WebsetItemsClient;
    /**
     * Client for managing Webset Searches
     */
    searches: WebsetSearchesClient;
    /**
     * Client for managing Webset Enrichments
     */
    enrichments: WebsetEnrichmentsClient;
    /**
     * Client for managing Webset Monitors
     */
    monitors: WebsetMonitorsClient;
    /**
     * Client for managing Webset Webhooks
     */
    webhooks: WebsetWebhooksClient;
    /**
     * Initialize a new Websets client
     * @param client The Exa client instance
     */
    constructor(client: Exa);
    /**
     * Create a new Webset
     * @param params The Webset creation parameters
     * @returns The created Webset
     */
    create(params: CreateWebsetParameters, options?: {
        headers?: WebsetHeadersLike;
    }): Promise<Webset>;
    /**
     * Preview a webset
     * @param params The preview parameters
     * @returns The preview response showing how the query will be decomposed
     */
    preview(params: PreviewWebsetParameters): Promise<PreviewWebsetResponse>;
    /**
     * Get a Webset by ID
     * @param id The ID of the Webset
     * @param expand Optional array of relations to expand
     * @returns The Webset
     */
    get(id: string, expand?: Array<"items">): Promise<GetWebsetResponse>;
    /**
     * List all Websets
     * @param options Pagination options (filtering by status is not supported by API)
     * @returns The list of Websets
     */
    list(options?: ListWebsetsOptions): Promise<ListWebsetsResponse>;
    /**
     * Iterate through all Websets, handling pagination automatically
     * @param options Pagination options
     * @returns Async generator of Websets
     */
    listAll(options?: ListWebsetsOptions): AsyncGenerator<Webset>;
    /**
     * Collect all Websets into an array
     * @param options Pagination options
     * @returns Promise resolving to an array of all Websets
     */
    getAll(options?: ListWebsetsOptions): Promise<Webset[]>;
    /**
     * Update a Webset
     * @param id The ID of the Webset
     * @param params The Webset update parameters
     * @returns The updated Webset
     */
    update(id: string, params: UpdateWebsetRequest): Promise<Webset>;
    /**
     * Delete a Webset
     * @param id The ID of the Webset
     * @returns The deleted Webset
     */
    delete(id: string): Promise<Webset>;
    /**
     * Cancel a running Webset
     * @param id The ID or external ID of the Webset
     * @returns The canceled Webset (as returned by the API)
     */
    cancel(id: string): Promise<Webset>;
    /**
     * Wait until a Webset is idle
     * @param id The ID of the Webset
     * @param options Configuration options for timeout and polling
     * @returns The Webset once it becomes idle
     * @throws Error if the Webset does not become idle within the timeout
     */
    waitUntilIdle(id: string, options?: {
        timeout?: number;
        pollInterval?: number;
        onPoll?: (status: WebsetStatus) => void;
    } | number): Promise<Webset>;
}

type QueryParams = Record<string, string | number | boolean | string[] | undefined>;
interface RequestBody {
    [key: string]: unknown;
}
/**
 * Base client class for all Research-related API clients
 */
declare class ResearchBaseClient {
    protected client: Exa;
    /**
     * Initialize a new Research base client
     * @param client The Exa client instance
     */
    constructor(client: Exa);
    /**
     * Make a request to the Research API (prefixes all paths with `/research`).
     * @param endpoint The endpoint path, beginning with a slash (e.g. "/tasks").
     * @param method The HTTP method. Defaults to "POST".
     * @param data Optional request body
     * @param params Optional query parameters
     * @returns The parsed JSON response
     */
    protected request<T = unknown>(endpoint: string, method?: string, data?: RequestBody, params?: QueryParams): Promise<T>;
    /**
     * Make a request to the Research API (prefixes all paths with `/research`).
     * @param endpoint The endpoint path, beginning with a slash (e.g. "/tasks").
     * @param method The HTTP method. Defaults to "POST".
     * @param data Optional request body
     * @param params Optional query parameters
     * @returns The parsed JSON response
     */
    protected rawRequest(endpoint: string, method?: string, data?: RequestBody, params?: QueryParams): Promise<Response>;
    /**
     * Helper to build pagination parameters.
     * @param pagination The pagination parameters
     * @returns QueryParams object with pagination parameters
     */
    protected buildPaginationParams(pagination?: SchemaListResearchTasksRequestDto): QueryParams;
}

/**
 * Client for interacting with the Research Tasks API.
 */
declare class ResearchClient extends ResearchBaseClient {
    constructor(client: Exa);
    /**
     * Create a new research task with Zod schema for strongly typed output
     */
    createTask<T>(params: ResearchCreateTaskParamsTyped<ZodSchema<T>>): Promise<SchemaResearchCreateTaskResponseDto>;
    /**
     * Create a new research task.
     *
     * @param params Object containing:
     *   - model: The research model to use (e.g., ResearchModel.ExaResearch).
     *   - instructions: High-level guidance for the research agent.
     *   - output: An object with a `schema` property (JSONSchema) that defines the expected output structure.
     *
     * @returns An object containing the unique ID of the created research task.
     */
    createTask(params: {
        instructions: string;
        model?: "exa-research" | "exa-research-pro";
        output?: {
            inferSchema?: boolean;
            schema?: JSONSchema;
        };
    }): Promise<SchemaResearchCreateTaskResponseDto>;
    /**
     * Retrieve a research task by ID.
     *
     * Overloads:
     *   - getTask(id)
     *   - getTask(id, {stream: false})
     *     => Promise<ResearchTask>
     *   - getTask(id, {stream: true})
     *     => AsyncGenerator<ResearchTaskEvent>
     */
    getTask(id: string): Promise<SchemaResearchTaskDto>;
    getTask(id: string, options: {
        stream?: false;
    }): Promise<SchemaResearchTaskDto>;
    getTask(id: string, options: {
        stream: true;
    }): Promise<AsyncGenerator<ResearchTaskEvent, any, any>>;
    /**
     * @deprecated This method is deprecated and may be removed in a future release.
     * @see getTask(id, {stream: true})
     * Poll a research task until completion or failure.
     * Polls every 1 second with a maximum timeout of 10 minutes.
     * Resilient to up to 10 consecutive polling failures.
     */
    pollTask(id: string): Promise<SchemaResearchTaskDto>;
    /**
     * List research tasks
     * @param options Pagination options
     * @returns The paginated list of research tasks
     */
    listTasks(options?: SchemaListResearchTasksRequestDto): Promise<SchemaListResearchTasksResponseDto>;
}

interface components {
    schemas: {
        ListResearchTasksRequestDto: {
            /** @description The cursor to paginate through the results */
            cursor?: string;
            /**
             * @description The number of results to return
             * @default 10
             */
            limit: number;
        };
        ListResearchTasksResponseDto: {
            /** @description The list of research tasks */
            data: components["schemas"]["ResearchTaskDto"][];
            /** @description Whether there are more results to paginate through */
            hasMore: boolean;
            /** @description The cursor to paginate through the next set of results */
            nextCursor: string | null;
        };
        ResearchCreateOpenAIResponseDto: {
            input: string;
            instructions?: string;
            /** @enum {string} */
            model: "exa-research" | "exa-research-pro";
            stream?: boolean;
            text?: {
                format?: {
                    /** @enum {string} */
                    type: "text";
                } | {
                    description?: string;
                    name?: string;
                    schema: {
                        [key: string]: unknown;
                    };
                    strict?: boolean;
                    /** @enum {string} */
                    type: "json_schema";
                };
            };
        };
        ResearchCreateTaskRequestDto: {
            input?: {
                instructions: string;
            };
            /** @description Instructions for what the research task should accomplish */
            instructions?: string;
            /**
             * @default exa-research
             * @enum {string}
             */
            model: "exa-research" | "exa-research-pro";
            output?: {
                /**
                 * @description When true and an output schema is omitted, an output schema will be intelligently generated. Otherwise, if this is false and there is no output schema, a generic markdown report will be generated.
                 * @default true
                 */
                inferSchema: boolean;
                /** @description A JsonSchema specification of the desired output. See https://json-schema.org/draft-07. */
                schema?: unknown;
            };
        };
        ResearchCreateTaskResponseDto: {
            /** @description The unique identifier for the research task */
            id: string;
            outputSchema: {
                [key: string]: unknown;
            };
        };
        ResearchTaskDto: {
            /** @description Citations grouped by the root field they were used in */
            citations?: {
                [key: string]: {
                    id: string;
                    snippet: string;
                    title?: string;
                    url: string;
                }[];
            };
            costDollars?: {
                research: {
                    pages: number;
                    reasoningTokens: number;
                    searches: number;
                };
                total: number;
            };
            /** @description The creation time of the research task in milliseconds since the Unix epoch */
            createdAt: number;
            /** @description The research results data conforming to the specified schema */
            data?: {
                [key: string]: unknown;
            };
            /** @description The unique identifier for the research task */
            id: string;
            /** @description The instructions or query for the research task */
            instructions: string;
            /** @enum {string} */
            model?: "exa-research" | "exa-research-pro";
            operations: ({
                stepId: string;
                /** @description Agent generated plan or reasoning for upcoming actions. */
                text: string;
                /** @enum {string} */
                type: "step-plan";
            } | {
                /** @description A completed subfield */
                data: {
                    [key: string]: unknown;
                };
                stepId: string;
                /** @enum {string} */
                type: "step-data";
            } | {
                /** @description What the agent hopes to find with this search query */
                goal?: string;
                /** @description Search query used */
                query: string;
                results?: {
                    id: string;
                    snippet: string;
                    title?: string;
                    url: string;
                    /** @enum {number} */
                    version: 1;
                }[];
                stepId: string;
                /** @enum {string} */
                type: "search";
            } | {
                /** @description What the agent hopes to find with this crawl */
                goal?: string;
                stepId: string;
                /** @enum {string} */
                type: "crawl";
                url: string;
            } | {
                stepId: string;
                /** @description Intermediate chain-of-thought style reasoning output */
                thought: string;
                /** @enum {string} */
                type: "think";
            })[];
            /** @description The JSON schema specification for the expected output format */
            schema?: {
                [key: string]: unknown;
            };
            /**
             * @description The current status of the research task
             * @enum {string}
             */
            status: "running" | "completed" | "failed";
            timeMs?: number;
        };
        ResearchTaskEventDto: {
            operation: {
                stepId: string;
                /** @description Agent generated plan or reasoning for upcoming actions. */
                text: string;
                /** @enum {string} */
                type: "step-plan";
            } | {
                /** @description A completed subfield */
                data: {
                    [key: string]: unknown;
                };
                stepId: string;
                /** @enum {string} */
                type: "step-data";
            } | {
                /** @description What the agent hopes to find with this search query */
                goal?: string;
                /** @description Search query used */
                query: string;
                results?: {
                    id: string;
                    snippet: string;
                    title?: string;
                    url: string;
                    /** @enum {number} */
                    version: 1;
                }[];
                stepId: string;
                /** @enum {string} */
                type: "search";
            } | {
                /** @description What the agent hopes to find with this crawl */
                goal?: string;
                stepId: string;
                /** @enum {string} */
                type: "crawl";
                url: string;
            } | {
                stepId: string;
                /** @description Intermediate chain-of-thought style reasoning output */
                thought: string;
                /** @enum {string} */
                type: "think";
            };
            /** @enum {string} */
            type: "operation";
        } | {
            task: {
                /** @description Citations grouped by the root field they were used in */
                citations?: {
                    [key: string]: {
                        id: string;
                        snippet: string;
                        title?: string;
                        url: string;
                    }[];
                };
                costDollars?: {
                    research: {
                        pages: number;
                        reasoningTokens: number;
                        searches: number;
                    };
                    total: number;
                };
                /** @description The creation time of the research task in milliseconds since the Unix epoch */
                createdAt: number;
                /** @description The research results data conforming to the specified schema */
                data?: {
                    [key: string]: unknown;
                };
                /** @description The unique identifier for the research task */
                id: string;
                /** @description The instructions or query for the research task */
                instructions: string;
                /** @enum {string} */
                model?: "exa-research" | "exa-research-pro";
                operations: ({
                    stepId: string;
                    /** @description Agent generated plan or reasoning for upcoming actions. */
                    text: string;
                    /** @enum {string} */
                    type: "step-plan";
                } | {
                    /** @description A completed subfield */
                    data: {
                        [key: string]: unknown;
                    };
                    stepId: string;
                    /** @enum {string} */
                    type: "step-data";
                } | {
                    /** @description What the agent hopes to find with this search query */
                    goal?: string;
                    /** @description Search query used */
                    query: string;
                    results?: {
                        id: string;
                        snippet: string;
                        title?: string;
                        url: string;
                        /** @enum {number} */
                        version: 1;
                    }[];
                    stepId: string;
                    /** @enum {string} */
                    type: "search";
                } | {
                    /** @description What the agent hopes to find with this crawl */
                    goal?: string;
                    stepId: string;
                    /** @enum {string} */
                    type: "crawl";
                    url: string;
                } | {
                    stepId: string;
                    /** @description Intermediate chain-of-thought style reasoning output */
                    thought: string;
                    /** @enum {string} */
                    type: "think";
                })[];
                /** @description The JSON schema specification for the expected output format */
                schema?: {
                    [key: string]: unknown;
                };
                /**
                 * @description The current status of the research task
                 * @enum {string}
                 */
                status: "running" | "completed" | "failed";
                timeMs?: number;
            };
            /** @enum {string} */
            type: "completed";
        };
        ResearchTaskOperationDto: {
            stepId: string;
            /** @description Agent generated plan or reasoning for upcoming actions. */
            text: string;
            /** @enum {string} */
            type: "step-plan";
        } | {
            /** @description A completed subfield */
            data: {
                [key: string]: unknown;
            };
            stepId: string;
            /** @enum {string} */
            type: "step-data";
        } | {
            /** @description What the agent hopes to find with this search query */
            goal?: string;
            /** @description Search query used */
            query: string;
            results?: {
                id: string;
                snippet: string;
                title?: string;
                url: string;
                /** @enum {number} */
                version: 1;
            }[];
            stepId: string;
            /** @enum {string} */
            type: "search";
        } | {
            /** @description What the agent hopes to find with this crawl */
            goal?: string;
            stepId: string;
            /** @enum {string} */
            type: "crawl";
            url: string;
        } | {
            stepId: string;
            /** @description Intermediate chain-of-thought style reasoning output */
            thought: string;
            /** @enum {string} */
            type: "think";
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
type SchemaListResearchTasksRequestDto = components["schemas"]["ListResearchTasksRequestDto"];
type SchemaListResearchTasksResponseDto = components["schemas"]["ListResearchTasksResponseDto"];
type SchemaResearchCreateTaskRequestDto = components["schemas"]["ResearchCreateTaskRequestDto"];
type SchemaResearchCreateTaskResponseDto = components["schemas"]["ResearchCreateTaskResponseDto"];
type SchemaResearchTaskDto = components["schemas"]["ResearchTaskDto"];

type ResearchTaskEvent = components["schemas"]["ResearchTaskEventDto"];
type ResearchTaskOperation = SchemaResearchTaskDto["operations"][0];

/**
 * HTTP status codes
 */
declare enum HttpStatusCode {
    BadRequest = 400,
    NotFound = 404,
    Unauthorized = 401,
    Forbidden = 403,
    TooManyRequests = 429,
    RequestTimeout = 408,
    InternalServerError = 500,
    ServiceUnavailable = 503
}
/**
 * Base error class for all Exa API errors
 */
declare class ExaError extends Error {
    /**
     * HTTP status code
     */
    statusCode: number;
    /**
     * ISO timestamp from API
     */
    timestamp?: string;
    /**
     * Path that caused the error (may be undefined for client-side errors)
     */
    path?: string;
    /**
     * Create a new ExaError
     * @param message Error message
     * @param statusCode HTTP status code
     * @param timestamp ISO timestamp from API
     * @param path Path that caused the error
     */
    constructor(message: string, statusCode: number, timestamp?: string, path?: string);
}

declare const isBeta = false;
/**
 * Search options for performing a search query.
 * @typedef {Object} SearchOptions
 * @property {number} [numResults] - Number of search results to return. Default 10. Max 10 for basic plans.
 * @property {string[]} [includeDomains] - List of domains to include in the search.
 * @property {string[]} [excludeDomains] - List of domains to exclude in the search.
 * @property {string} [startCrawlDate] - Start date for results based on crawl date.
 * @property {string} [endCrawlDate] - End date for results based on crawl date.
 * @property {string} [startPublishedDate] - Start date for results based on published date.
 * @property {string} [endPublishedDate] - End date for results based on published date.
 * @property {string} [category] - A data category to focus on, with higher comprehensivity and data cleanliness. Currently, the only category is company.
 * @property {string[]} [includeText] - List of strings that must be present in webpage text of results. Currently only supports 1 string of up to 5 words.
 * @property {string[]} [excludeText] - List of strings that must not be present in webpage text of results. Currently only supports 1 string of up to 5 words.
 * @property {string[]} [flags] - Experimental flags
 * @property {string} [userLocation] - The two-letter ISO country code of the user, e.g. US.
 */
type BaseSearchOptions = {
    numResults?: number;
    includeDomains?: string[];
    excludeDomains?: string[];
    startCrawlDate?: string;
    endCrawlDate?: string;
    startPublishedDate?: string;
    endPublishedDate?: string;
    category?: "company" | "research paper" | "news" | "pdf" | "github" | "tweet" | "personal site" | "linkedin profile" | "financial report";
    includeText?: string[];
    excludeText?: string[];
    flags?: string[];
    userLocation?: string;
};
/**
 * Search options for performing a search query.
 * @typedef {Object} RegularSearchOptions
 */
type RegularSearchOptions = BaseSearchOptions & {
    /**
     * If true, the search results are moderated for safety.
     */
    moderation?: boolean;
    useAutoprompt?: boolean;
    type?: "keyword" | "neural" | "auto" | "hybrid" | "fast";
};
/**
 * Options for finding similar links.
 * @typedef {Object} FindSimilarOptions
 * @property {boolean} [excludeSourceDomain] - If true, excludes links from the base domain of the input.
 */
type FindSimilarOptions = BaseSearchOptions & {
    excludeSourceDomain?: boolean;
};
type ExtrasOptions = {
    links?: number;
    imageLinks?: number;
};
/**
 * Search options for performing a search query.
 * @typedef {Object} ContentsOptions
 * @property {TextContentsOptions | boolean} [text] - Options for retrieving text contents.
 * @property {HighlightsContentsOptions | boolean} [highlights] - Options for retrieving highlights.
 * @property {SummaryContentsOptions | boolean} [summary] - Options for retrieving summary.
 * @property {LivecrawlOptions} [livecrawl] - Options for livecrawling contents. Default is "never" for neural/auto search, "fallback" for keyword search.
 * @property {number} [livecrawlTimeout] - The timeout for livecrawling. Max and default is 10000ms.
 * @property {boolean} [filterEmptyResults] - If true, filters out results with no contents. Default is true.
 * @property {number} [subpages] - The number of subpages to return for each result, where each subpage is derived from an internal link for the result.
 * @property {string | string[]} [subpageTarget] - Text used to match/rank subpages in the returned subpage list. You could use "about" to get *about* page for websites. Note that this is a fuzzy matcher.
 * @property {ExtrasOptions} [extras] - Miscelleneous data derived from results
 */
type ContentsOptions = {
    text?: TextContentsOptions | true;
    highlights?: HighlightsContentsOptions | true;
    summary?: SummaryContentsOptions | true;
    livecrawl?: LivecrawlOptions;
    context?: ContextOptions | true;
    livecrawlTimeout?: number;
    filterEmptyResults?: boolean;
    subpages?: number;
    subpageTarget?: string | string[];
    extras?: ExtrasOptions;
} & (typeof isBeta extends true ? {} : {});
/**
 * Options for livecrawling contents
 * @typedef {string} LivecrawlOptions
 */
type LivecrawlOptions = "never" | "fallback" | "always" | "auto" | "preferred";
/**
 * Options for retrieving text from page.
 * @typedef {Object} TextContentsOptions
 * @property {number} [maxCharacters] - The maximum number of characters to return.
 * @property {boolean} [includeHtmlTags] - If true, includes HTML tags in the returned text. Default: false
 */
type TextContentsOptions = {
    maxCharacters?: number;
    includeHtmlTags?: boolean;
};
/**
 * Options for retrieving highlights from page.
 * @typedef {Object} HighlightsContentsOptions
 * @property {string} [query] - The query string to use for highlights search.
 * @property {number} [numSentences] - The number of sentences to return for each highlight.
 * @property {number} [highlightsPerUrl] - The number of highlights to return for each URL.
 */
type HighlightsContentsOptions = {
    query?: string;
    numSentences?: number;
    highlightsPerUrl?: number;
};
/**
 * Options for retrieving summary from page.
 * @typedef {Object} SummaryContentsOptions
 * @property {string} [query] - The query string to use for summary generation.
 * @property {JSONSchema} [schema] - JSON schema for structured output from summary.
 */
type SummaryContentsOptions = {
    query?: string;
    schema?: Record<string, unknown> | ZodSchema;
};
/**
 * @deprecated Use Record<string, unknown> instead.
 */
type JSONSchema = Record<string, unknown>;
/**
 * Options for retrieving the context from a list of search results. The context is a string
 * representation of all the search results.
 * @typedef {Object} ContextOptions
 * @property {number} [maxCharacters] - The maximum number of characters.
 */
type ContextOptions = {
    maxCharacters?: number;
};
/**
 * @typedef {Object} TextResponse
 * @property {string} text - Text from page
 */
type TextResponse = {
    text: string;
};
/**
 * @typedef {Object} HighlightsResponse
 * @property {string[]} highlights - The highlights as an array of strings.
 * @property {number[]} highlightScores - The corresponding scores as an array of floats, 0 to 1
 */
type HighlightsResponse = {
    highlights: string[];
    highlightScores: number[];
};
/**
 * @typedef {Object} SummaryResponse
 * @property {string} summary - The generated summary of the page content.
 */
type SummaryResponse = {
    summary: string;
};
/**
 * @typedef {Object} ExtrasResponse
 * @property {string[]} links - The links on the page of a result
 * @property {string[]} imageLinks - The image links on the page of a result
 */
type ExtrasResponse = {
    extras: {
        links?: string[];
        imageLinks?: string[];
    };
};
/**
 * @typedef {Object} SubpagesResponse
 * @property {ContentsResultComponent<T extends ContentsOptions>} subpages - The subpages for a result
 */
type SubpagesResponse<T extends ContentsOptions> = {
    subpages: ContentsResultComponent<T>[];
};
type Default<T extends {}, U> = [keyof T] extends [never] ? U : T;
/**
 * @typedef {Object} ContentsResultComponent
 * Depending on 'ContentsOptions', this yields a combination of 'TextResponse', 'HighlightsResponse', 'SummaryResponse', or an empty object.
 *
 * @template T - A type extending from 'ContentsOptions'.
 */
type ContentsResultComponent<T extends ContentsOptions> = Default<(T["text"] extends object | true ? TextResponse : {}) & (T["highlights"] extends object | true ? HighlightsResponse : {}) & (T["summary"] extends object | true ? SummaryResponse : {}) & (T["subpages"] extends number ? SubpagesResponse<T> : {}) & (T["extras"] extends object ? ExtrasResponse : {}), TextResponse>;
/**
 * Represents the cost breakdown related to contents retrieval. Fields are optional because
 * only non-zero costs are included.
 * @typedef {Object} CostDollarsContents
 * @property {number} [text] - The cost in dollars for retrieving text.
 * @property {number} [highlights] - The cost in dollars for retrieving highlights.
 * @property {number} [summary] - The cost in dollars for retrieving summary.
 */
type CostDollarsContents = {
    text?: number;
    highlights?: number;
    summary?: number;
};
/**
 * Represents the cost breakdown related to search. Fields are optional because
 * only non-zero costs are included.
 * @typedef {Object} CostDollarsSeearch
 * @property {number} [neural] - The cost in dollars for neural search.
 * @property {number} [keyword] - The cost in dollars for keyword search.
 */
type CostDollarsSeearch = {
    neural?: number;
    keyword?: number;
};
/**
 * Represents the total cost breakdown. Only non-zero costs are included.
 * @typedef {Object} CostDollars
 * @property {number} total - The total cost in dollars.
 * @property {CostDollarsSeearch} [search] - The cost breakdown for search.
 * @property {CostDollarsContents} [contents] - The cost breakdown for contents.
 */
type CostDollars = {
    total: number;
    search?: CostDollarsSeearch;
    contents?: CostDollarsContents;
};
/**
 * Represents a search result object.
 * @typedef {Object} SearchResult
 * @property {string} title - The title of the search result.
 * @property {string} url - The URL of the search result.
 * @property {string} [publishedDate] - The estimated creation date of the content.
 * @property {string} [author] - The author of the content, if available.
 * @property {number} [score] - Similarity score between the query/url and the result.
 * @property {string} id - The temporary ID for the document.
 * @property {string} [image] - A representative image for the content, if any.
 * @property {string} [favicon] - A favicon for the site, if any.
 */
type SearchResult<T extends ContentsOptions> = {
    title: string | null;
    url: string;
    publishedDate?: string;
    author?: string;
    score?: number;
    id: string;
    image?: string;
    favicon?: string;
} & ContentsResultComponent<T>;
/**
 * Represents a search response object.
 * @typedef {Object} SearchResponse
 * @property {Result[]} results - The list of search results.
 * @property {string} [context] - The context for the search.
 * @property {string} [autopromptString] - The autoprompt string, if applicable.
 * @property {string} [autoDate] - The autoprompt date, if applicable.
 * @property {string} requestId - The request ID for the search.
 * @property {CostDollars} [costDollars] - The cost breakdown for this request.
 */
type SearchResponse<T extends ContentsOptions> = {
    results: SearchResult<T>[];
    context?: string;
    autopromptString?: string;
    autoDate?: string;
    requestId: string;
    statuses?: Array<Status>;
    costDollars?: CostDollars;
};
type Status = {
    id: string;
    status: string;
    source: string;
};
/**
 * Options for the answer endpoint
 * @typedef {Object} AnswerOptions
 * @property {boolean} [stream] - Whether to stream the response. Default false.
 * @property {boolean} [text] - Whether to include text in the source results. Default false.
 * @property {"exa"} [model] - The model to use for generating the answer. Default "exa".
 * @property {string} [systemPrompt] - A system prompt to guide the LLM's behavior when generating the answer.
 * @property {Object} [outputSchema] - A JSON Schema specification for the structure you expect the output to take
 */
type AnswerOptions = {
    stream?: boolean;
    text?: boolean;
    model?: "exa";
    systemPrompt?: string;
    outputSchema?: Record<string, unknown>;
};
/**
 * Represents an answer response object from the /answer endpoint.
 * @typedef {Object} AnswerResponse
 * @property {string | Object} answer - The generated answer text (or an object matching `outputSchema`, if provided)
 * @property {SearchResult<{}>[]} citations - The sources used to generate the answer.
 * @property {CostDollars} [costDollars] - The cost breakdown for this request.
 * @property {string} [requestId] - Optional request ID for the answer.
 */
type AnswerResponse = {
    answer: string | Record<string, unknown>;
    citations: SearchResult<{}>[];
    requestId?: string;
    costDollars?: CostDollars;
};
type AnswerStreamChunk = {
    /**
     * The partial text content of the answer (if present in this chunk).
     */
    content?: string;
    /**
     * Citations associated with the current chunk of text (if present).
     */
    citations?: Array<{
        id: string;
        url: string;
        title?: string;
        publishedDate?: string;
        author?: string;
        text?: string;
    }>;
};
/**
 * Represents a streaming answer response chunk from the /answer endpoint.
 * @typedef {Object} AnswerStreamResponse
 * @property {string} [answer] - A chunk of the generated answer text.
 * @property {SearchResult<{}>[]]} [citations] - The sources used to generate the answer.
 */
type AnswerStreamResponse = {
    answer?: string;
    citations?: SearchResult<{}>[];
};
/**
 * Enhanced answer options that accepts either JSON schema or Zod schema
 */
type AnswerOptionsTyped<T> = Omit<AnswerOptions, "outputSchema"> & {
    outputSchema: T;
};
/**
 * Enhanced answer response with strongly typed answer when using Zod
 */
type AnswerResponseTyped<T> = Omit<AnswerResponse, "answer"> & {
    answer: T;
};
/**
 * Enhanced summary contents options that accepts either JSON schema or Zod schema
 */
type SummaryContentsOptionsTyped<T> = Omit<SummaryContentsOptions, "schema"> & {
    schema: T;
};
/**
 * Enhanced research task output options that accepts either JSON schema or Zod schema
 */
type ResearchTaskOutputTyped<T> = {
    inferSchema?: boolean;
    schema: T;
};
/**
 * Enhanced research task creation params with zod schema support
 */
type ResearchCreateTaskParamsTyped<T> = {
    instructions: string;
    model?: "exa-research" | "exa-research-pro";
    output?: ResearchTaskOutputTyped<T>;
};
/**
 * The Exa class encapsulates the API's endpoints.
 */
declare class Exa {
    private baseURL;
    private headers;
    /**
     * Websets API client
     */
    websets: WebsetsClient;
    /**
     * Research API client
     */
    research: ResearchClient;
    /**
     * Helper method to separate out the contents-specific options from the rest.
     */
    private extractContentsOptions;
    /**
     * Constructs the Exa API client.
     * @param {string} apiKey - The API key for authentication.
     * @param {string} [baseURL] - The base URL of the Exa API.
     */
    constructor(apiKey?: string, baseURL?: string);
    /**
     * Makes a request to the Exa API.
     * @param {string} endpoint - The API endpoint to call.
     * @param {string} method - The HTTP method to use.
     * @param {any} [body] - The request body for POST requests.
     * @param {Record<string, any>} [params] - The query parameters.
     * @returns {Promise<any>} The response from the API.
     * @throws {ExaError} When any API request fails with structured error information
     */
    request<T = unknown>(endpoint: string, method: string, body?: any, params?: Record<string, any>, headers?: Record<string, string>): Promise<T>;
    rawRequest(endpoint: string, method?: string, body?: Record<string, unknown>, queryParams?: Record<string, string | number | boolean | string[] | undefined>): Promise<Response>;
    /**
     * Performs a search with an Exa prompt-engineered query.
     *
     * @param {string} query - The query string.
     * @param {RegularSearchOptions} [options] - Additional search options
     * @returns {Promise<SearchResponse<{}>>} A list of relevant search results.
     */
    search(query: string, options?: RegularSearchOptions): Promise<SearchResponse<{}>>;
    /**
     * Performs a search with an Exa prompt-engineered query and returns the contents of the documents.
     *
     * @param {string} query - The query string.
     * @param {RegularSearchOptions & T} [options] - Additional search + contents options
     * @returns {Promise<SearchResponse<T>>} A list of relevant search results with requested contents.
     */
    searchAndContents<T extends ContentsOptions>(query: string, options?: RegularSearchOptions & T): Promise<SearchResponse<T>>;
    /**
     * Finds similar links to the provided URL.
     * @param {string} url - The URL for which to find similar links.
     * @param {FindSimilarOptions} [options] - Additional options for finding similar links.
     * @returns {Promise<SearchResponse<{}>>} A list of similar search results.
     */
    findSimilar(url: string, options?: FindSimilarOptions): Promise<SearchResponse<{}>>;
    /**
     * Finds similar links to the provided URL and returns the contents of the documents.
     * @param {string} url - The URL for which to find similar links.
     * @param {FindSimilarOptions & T} [options] - Additional options for finding similar links + contents.
     * @returns {Promise<SearchResponse<T>>} A list of similar search results, including requested contents.
     */
    findSimilarAndContents<T extends ContentsOptions>(url: string, options?: FindSimilarOptions & T): Promise<SearchResponse<T>>;
    /**
     * Retrieves contents of documents based on URLs.
     * @param {string | string[] | SearchResult[]} urls - A URL or array of URLs, or an array of SearchResult objects.
     * @param {ContentsOptions} [options] - Additional options for retrieving document contents.
     * @returns {Promise<SearchResponse<T>>} A list of document contents for the requested URLs.
     */
    getContents<T extends ContentsOptions>(urls: string | string[] | SearchResult<T>[], options?: T): Promise<SearchResponse<T>>;
    /**
     * Generate an answer with Zod schema for strongly typed output
     */
    answer<T>(query: string, options: AnswerOptionsTyped<ZodSchema<T>>): Promise<AnswerResponseTyped<T>>;
    /**
     * Generate an answer to a query.
     * @param {string} query - The question or query to answer.
     * @param {AnswerOptions} [options] - Additional options for answer generation.
     * @returns {Promise<AnswerResponse>} The generated answer and source references.
     *
     * Example with systemPrompt:
     * ```ts
     * const answer = await exa.answer("What is quantum computing?", {
     *   text: true,
     *   model: "exa",
     *   systemPrompt: "Answer in a technical manner suitable for experts."
     * });
     * ```
     *
     * Note: For streaming responses, use the `streamAnswer` method:
     * ```ts
     * for await (const chunk of exa.streamAnswer(query)) {
     *   // Handle chunks
     * }
     * ```
     */
    answer(query: string, options?: AnswerOptions): Promise<AnswerResponse>;
    /**
     * Stream an answer with Zod schema for structured output (non-streaming content)
     * Note: Structured output works only with non-streaming content, not with streaming chunks
     */
    streamAnswer<T>(query: string, options: {
        text?: boolean;
        model?: "exa" | "exa-pro";
        systemPrompt?: string;
        outputSchema: ZodSchema<T>;
    }): AsyncGenerator<AnswerStreamChunk>;
    /**
     * Stream an answer as an async generator
     *
     * Each iteration yields a chunk with partial text (`content`) or new citations.
     * Use this if you'd like to read the answer incrementally, e.g. in a chat UI.
     *
     * Example usage:
     * ```ts
     * for await (const chunk of exa.streamAnswer("What is quantum computing?", {
     *   text: false,
     *   systemPrompt: "Answer in a concise manner suitable for beginners."
     * })) {
     *   if (chunk.content) process.stdout.write(chunk.content);
     *   if (chunk.citations) {
     *     console.log("\nCitations: ", chunk.citations);
     *   }
     * }
     * ```
     */
    streamAnswer(query: string, options?: {
        text?: boolean;
        model?: "exa" | "exa-pro";
        systemPrompt?: string;
        outputSchema?: Record<string, unknown>;
    }): AsyncGenerator<AnswerStreamChunk>;
    private processChunk;
    private parseSSEStream;
}

export { type AnswerOptions, type AnswerOptionsTyped, type AnswerResponse, type AnswerResponseTyped, type AnswerStreamChunk, type AnswerStreamResponse, type ArticleEntity, type BaseSearchOptions, type CompanyEntity, type ContentsOptions, type ContentsResultComponent, type ContextOptions, type CostDollars, type CostDollarsContents, type CostDollarsSeearch, type CreateCriterionParameters, type CreateEnrichmentParameters, CreateEnrichmentParametersFormat, type CreateImportParameters, CreateImportParametersFormat, type CreateImportResponse, type CreateImportWithCsvParameters, type CreateMonitorParameters, type CreateWebhookParameters, type CreateWebsetParameters, CreateWebsetParametersImportSource, CreateWebsetParametersSearchExcludeSource, type CreateWebsetSearchParameters, CreateWebsetSearchParametersExcludeSource, CreateWebsetSearchParametersScopeSource, type CsvDataInput, type CustomEntity, type Default, type EnrichmentResult, type Entity, type Event, EventType, EventsClient, Exa, ExaError, type ExtrasOptions, type ExtrasResponse, type FindSimilarOptions, type GetWebsetResponse, type HighlightsContentsOptions, type HighlightsResponse, HttpStatusCode, type Import, ImportFailedReason, ImportFormat, ImportObject, ImportStatus, ImportsClient, type JSONSchema, type ListEventsResponse, type ListImportsResponse, type ListMonitorRunsResponse, type ListMonitorsOptions, type ListMonitorsResponse, type SchemaListResearchTasksRequestDto as ListResearchTasksRequest, type SchemaListResearchTasksResponseDto as ListResearchTasksResponse, type ListWebhookAttemptsResponse, type ListWebhooksResponse, type ListWebsetItemResponse, type ListWebsetItemsOptions, type ListWebsetsResponse, type LivecrawlOptions, type Monitor, type MonitorBehavior, type MonitorCadence, MonitorObject, type MonitorRun, MonitorRunObject, MonitorRunStatus, MonitorRunType, MonitorStatus, type PersonEntity, type PreviewWebsetParameters, type PreviewWebsetResponse, PreviewWebsetResponseEnrichmentsFormat, type RegularSearchOptions, ResearchClient, type ResearchCreateTaskParamsTyped, type SchemaResearchCreateTaskRequestDto as ResearchCreateTaskRequest, type SchemaResearchCreateTaskResponseDto as ResearchCreateTaskResponse, type ResearchPaperEntity, type SchemaResearchTaskDto as ResearchTask, type ResearchTaskEvent, type ResearchTaskOperation, type ResearchTaskOutputTyped, ScopeSourceType, type SearchResponse, type SearchResult, type Status, type SubpagesResponse, type SummaryContentsOptions, type SummaryContentsOptionsTyped, type SummaryResponse, type TextContentsOptions, type TextResponse, type UpdateImport, type UpdateMonitor, UpdateMonitorStatus, type UpdateWebhookParameters, type UpdateWebsetRequest, type WaitUntilCompletedOptions, type Webhook, type WebhookAttempt, WebhookStatus, type Webset, type WebsetEnrichment, WebsetEnrichmentFormat, WebsetEnrichmentStatus, WebsetEnrichmentsClient, type WebsetHeadersLike, type WebsetItem, type WebsetItemArticleProperties, type WebsetItemCompanyProperties, type WebsetItemCustomProperties, type WebsetItemEvaluation, WebsetItemEvaluationSatisfied, type WebsetItemPersonProperties, type WebsetItemResearchPaperProperties, WebsetItemSource, WebsetItemsClient, WebsetMonitorsClient, type WebsetSearch, WebsetSearchBehavior, WebsetSearchCanceledReason, WebsetSearchStatus, WebsetSearchesClient, WebsetStatus, WebsetWebhooksClient, WebsetsClient, Exa as default };

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OITracer = void 0;
const api_1 = require("@opentelemetry/api");
const OISpan_1 = require("./OISpan");
const traceConfig_1 = require("./traceConfig");
const contextAttributes_1 = require("../contextAttributes");
/**
 * Formats the params for the startActiveSpan method
 * The method has multiple overloads, so we need to format the arguments
 * Taken from @see https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-sdk-trace-base/src/Tracer.ts#L220C3-L235C6
 *
 */
function formatStartActiveSpanParams(arg2, arg3, arg4) {
    let opts;
    let ctx;
    let fn;
    if (typeof arg2 === "function") {
        fn = arg2;
    }
    else if (typeof arg3 === "function") {
        opts = arg2;
        fn = arg3;
    }
    else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
    }
    opts = opts !== null && opts !== void 0 ? opts : {};
    ctx = ctx !== null && ctx !== void 0 ? ctx : api_1.context.active();
    return { opts, ctx, fn };
}
/**
 * A wrapper around the OpenTelemetry {@link Tracer} interface that masks sensitive information based on the passed in {@link TraceConfig}.
 */
class OITracer {
    /**
     *
     * @param tracer The OpenTelemetry {@link Tracer} to wrap
     * @param traceConfig The {@link TraceConfigOptions} to set to control the behavior of the tracer
     */
    constructor({ tracer, traceConfig, }) {
        this.tracer = tracer;
        this.config = (0, traceConfig_1.generateTraceConfig)(traceConfig);
    }
    startActiveSpan(name, arg2, arg3, arg4) {
        const formattedArgs = formatStartActiveSpanParams(arg2, arg3, arg4);
        if (formattedArgs == null) {
            return;
        }
        const { opts, ctx, fn } = formattedArgs;
        const { attributes } = opts !== null && opts !== void 0 ? opts : {};
        const contextAttributes = (0, contextAttributes_1.getAttributesFromContext)(ctx);
        const mergedAttributes = Object.assign(Object.assign({}, contextAttributes), attributes);
        return this.tracer.startActiveSpan(name, Object.assign(Object.assign({}, opts), { attributes: undefined }), ctx, (span) => {
            const openInferenceSpan = new OISpan_1.OISpan({
                span,
                config: this.config,
            });
            openInferenceSpan.setAttributes(mergedAttributes);
            return fn(openInferenceSpan);
        });
    }
    startSpan(name, options, context) {
        const attributes = options === null || options === void 0 ? void 0 : options.attributes;
        const ctx = context !== null && context !== void 0 ? context : api_1.context.active();
        const contextAttributes = (0, contextAttributes_1.getAttributesFromContext)(ctx);
        const mergedAttributes = Object.assign(Object.assign({}, contextAttributes), attributes);
        const span = new OISpan_1.OISpan({
            span: this.tracer.startSpan(name, Object.assign(Object.assign({}, options), { attributes: undefined }), ctx),
            config: this.config,
        });
        span.setAttributes(mergedAttributes);
        return span;
    }
}
exports.OITracer = OITracer;
//# sourceMappingURL=OITracer.js.map
import { DeterminewhenToRetryRequestProps, RetryStrategy } from './retry-strategy';
import { EligibilityStrategy } from './eligibility-strategy';
import { MomentoLoggerFactory } from '../..';
/**
 * Properties for configuring the ExponentialBackoffRetryStrategy
 */
export interface ExponentialBackoffRetryStrategyProps {
    /**
     * Configures logging verbosity and format
     */
    loggerFactory: MomentoLoggerFactory;
    /**
     * Configures how and when failed requests will be retried
     */
    eligibilityStrategy?: EligibilityStrategy;
    /**
     * Initial delay for the first retry (in milliseconds)
     */
    initialDelayMillis?: number;
    /**
     * Maximum delay to cap the exponential growth (in milliseconds)
     */
    maxBackoffMillis?: number;
}
/**
 * Retry strategy that uses exponential backoff with decorrelated jitter.
 *
 * The backoff for each attempt is calculated as follows:
 * - The first retry has a fixed delay of `initialDelayMillis`
 * - Backoff for subsequent retries is calculated as `initialDelayMillis * 2^attemptNumber`
 * - Subsequent retries have a delay that is a random value between
 *   the current backoff and 3 times the previous backoff, with the
 *.  current backoff capped at `maxBackoffMillis`
 */
export declare class ExponentialBackoffRetryStrategy implements RetryStrategy {
    private readonly logger;
    private readonly eligibilityStrategy;
    private readonly initialDelayMillis;
    private readonly growthFactor;
    private readonly maxBackoffMillis;
    constructor(props: ExponentialBackoffRetryStrategyProps);
    determineWhenToRetryRequest(props: DeterminewhenToRetryRequestProps): number | null;
    /**
     * Compute the backoffed base delay for the given attempt number.
     * @param attemptNumber - The attempt number (0-based)
     * @returns The base delay for the given attempt number
     */
    private computeBaseDelay;
    private computePreviousBaseDelay;
}

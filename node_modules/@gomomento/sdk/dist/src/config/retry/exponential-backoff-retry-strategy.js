"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExponentialBackoffRetryStrategy = void 0;
const __1 = require("../..");
/*
 * Default parameters
 */
/**
 * Default initial delay for the first retry (in milliseconds).
 *
 * Note that Node.js `setTimeout` has a resolution of 1ms, so
 * the actual delay may be slightly longer.
 */
const DEFAULT_INITIAL_DELAY_MS = 0.5;
/**
 * Default growth factor for exponential backoff
 */
const DEFAULT_GROWTH_FACTOR = 2;
/**
 * Default maximum delay to cap the exponential growth (in milliseconds)
 */
const DEFAULT_MAX_BACKOFF_MS = 8.0;
/**
 * Retry strategy that uses exponential backoff with decorrelated jitter.
 *
 * The backoff for each attempt is calculated as follows:
 * - The first retry has a fixed delay of `initialDelayMillis`
 * - Backoff for subsequent retries is calculated as `initialDelayMillis * 2^attemptNumber`
 * - Subsequent retries have a delay that is a random value between
 *   the current backoff and 3 times the previous backoff, with the
 *.  current backoff capped at `maxBackoffMillis`
 */
class ExponentialBackoffRetryStrategy {
    constructor(props) {
        var _a, _b, _c;
        this.logger = props.loggerFactory.getLogger(this);
        this.eligibilityStrategy =
            (_a = props.eligibilityStrategy) !== null && _a !== void 0 ? _a : new __1.DefaultEligibilityStrategy(props.loggerFactory);
        this.initialDelayMillis =
            (_b = props.initialDelayMillis) !== null && _b !== void 0 ? _b : DEFAULT_INITIAL_DELAY_MS;
        this.growthFactor = DEFAULT_GROWTH_FACTOR;
        this.maxBackoffMillis = (_c = props.maxBackoffMillis) !== null && _c !== void 0 ? _c : DEFAULT_MAX_BACKOFF_MS;
    }
    determineWhenToRetryRequest(props) {
        this.logger.debug(`Determining whether request is eligible for retry; status code: ${props.grpcStatus.code}, request type: ${props.grpcRequest.path}, attemptNumber: ${props.attemptNumber}`);
        if (!this.eligibilityStrategy.isEligibleForRetry(props)) {
            this.logger.debug('Request is not eligible for retry.');
            return null; // Do not retry
        }
        const baseDelay = Math.min(this.computeBaseDelay(props.attemptNumber), this.maxBackoffMillis);
        const previousBaseDelay = this.computePreviousBaseDelay(baseDelay);
        const maxDelay = previousBaseDelay * 3;
        const jitteredDelay = randomInRange(baseDelay, maxDelay);
        this.logger.debug(`ExponentialBackoffRetryStrategy: attempt #${props.attemptNumber}` +
            ` -> base delay=${baseDelay}ms, max delay=${maxDelay}ms, jittered delay=${jitteredDelay}ms`);
        return jitteredDelay;
    }
    /**
     * Compute the backoffed base delay for the given attempt number.
     * @param attemptNumber - The attempt number (0-based)
     * @returns The base delay for the given attempt number
     */
    computeBaseDelay(attemptNumber) {
        if (attemptNumber <= 0) {
            return this.initialDelayMillis;
        }
        else {
            return (this.initialDelayMillis * Math.pow(this.growthFactor, attemptNumber));
        }
    }
    computePreviousBaseDelay(currentBaseDelay) {
        return currentBaseDelay / this.growthFactor;
    }
}
exports.ExponentialBackoffRetryStrategy = ExponentialBackoffRetryStrategy;
/**
 * Generate a uniform random number in the range [min, max)
 * @param min - Minimum value (inclusive)
 * @param max - Maximum value (exclusive)
 * @returns A random number in the range [min, max)
 */
function randomInRange(min, max) {
    if (min >= max) {
        return min;
    }
    return round(min + Math.random() * (max - min), 3);
}
/**
 * Round a number to a given number of decimal places
 *
 * @param value - The value to round
 * @param decimals - The number of decimal places
 * @returns The rounded value
 */
function round(value, decimals) {
    const factor = Math.pow(10, decimals);
    return Math.round(value * factor) / factor;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwb25lbnRpYWwtYmFja29mZi1yZXRyeS1zdHJhdGVneS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb25maWcvcmV0cnkvZXhwb25lbnRpYWwtYmFja29mZi1yZXRyeS1zdHJhdGVneS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFLQSw2QkFJZTtBQUVmOztHQUVHO0FBRUg7Ozs7O0dBS0c7QUFDSCxNQUFNLHdCQUF3QixHQUFHLEdBQUcsQ0FBQztBQUVyQzs7R0FFRztBQUNILE1BQU0scUJBQXFCLEdBQUcsQ0FBQyxDQUFDO0FBRWhDOztHQUVHO0FBQ0gsTUFBTSxzQkFBc0IsR0FBRyxHQUFHLENBQUM7QUEwQm5DOzs7Ozs7Ozs7R0FTRztBQUNILE1BQWEsK0JBQStCO0lBTzFDLFlBQVksS0FBMkM7O1FBQ3JELElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbEQsSUFBSSxDQUFDLG1CQUFtQjtZQUN0QixNQUFBLEtBQUssQ0FBQyxtQkFBbUIsbUNBQ3pCLElBQUksOEJBQTBCLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBRXRELElBQUksQ0FBQyxrQkFBa0I7WUFDckIsTUFBQSxLQUFLLENBQUMsa0JBQWtCLG1DQUFJLHdCQUF3QixDQUFDO1FBQ3ZELElBQUksQ0FBQyxZQUFZLEdBQUcscUJBQXFCLENBQUM7UUFDMUMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLE1BQUEsS0FBSyxDQUFDLGdCQUFnQixtQ0FBSSxzQkFBc0IsQ0FBQztJQUMzRSxDQUFDO0lBRUQsMkJBQTJCLENBQ3pCLEtBQXVDO1FBRXZDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUNmLG1FQUFtRSxLQUFLLENBQUMsVUFBVSxDQUFDLElBQUksbUJBQW1CLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxvQkFBb0IsS0FBSyxDQUFDLGFBQWEsRUFBRSxDQUMzSyxDQUFDO1FBRUYsSUFBSSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN2RCxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO1lBQ3hELE9BQU8sSUFBSSxDQUFDLENBQUMsZUFBZTtTQUM3QjtRQUVELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQ3hCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLEVBQzFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FDdEIsQ0FBQztRQUNGLE1BQU0saUJBQWlCLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ25FLE1BQU0sUUFBUSxHQUFHLGlCQUFpQixHQUFHLENBQUMsQ0FBQztRQUN2QyxNQUFNLGFBQWEsR0FBRyxhQUFhLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBRXpELElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUNmLDZDQUE2QyxLQUFLLENBQUMsYUFBYSxFQUFFO1lBQ2hFLGtCQUFrQixTQUFTLGlCQUFpQixRQUFRLHNCQUFzQixhQUFhLElBQUksQ0FDOUYsQ0FBQztRQUVGLE9BQU8sYUFBYSxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssZ0JBQWdCLENBQUMsYUFBcUI7UUFDNUMsSUFBSSxhQUFhLElBQUksQ0FBQyxFQUFFO1lBQ3RCLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDO1NBQ2hDO2FBQU07WUFDTCxPQUFPLENBQ0wsSUFBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxhQUFhLENBQUMsQ0FDckUsQ0FBQztTQUNIO0lBQ0gsQ0FBQztJQUVPLHdCQUF3QixDQUFDLGdCQUF3QjtRQUN2RCxPQUFPLGdCQUFnQixHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDOUMsQ0FBQztDQUNGO0FBakVELDBFQWlFQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBUyxhQUFhLENBQUMsR0FBVyxFQUFFLEdBQVc7SUFDN0MsSUFBSSxHQUFHLElBQUksR0FBRyxFQUFFO1FBQ2QsT0FBTyxHQUFHLENBQUM7S0FDWjtJQUNELE9BQU8sS0FBSyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDckQsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILFNBQVMsS0FBSyxDQUFDLEtBQWEsRUFBRSxRQUFnQjtJQUM1QyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUN0QyxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQztBQUM3QyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRGV0ZXJtaW5ld2hlblRvUmV0cnlSZXF1ZXN0UHJvcHMsXG4gIFJldHJ5U3RyYXRlZ3ksXG59IGZyb20gJy4vcmV0cnktc3RyYXRlZ3knO1xuaW1wb3J0IHtFbGlnaWJpbGl0eVN0cmF0ZWd5fSBmcm9tICcuL2VsaWdpYmlsaXR5LXN0cmF0ZWd5JztcbmltcG9ydCB7XG4gIERlZmF1bHRFbGlnaWJpbGl0eVN0cmF0ZWd5LFxuICBNb21lbnRvTG9nZ2VyRmFjdG9yeSxcbiAgTW9tZW50b0xvZ2dlcixcbn0gZnJvbSAnLi4vLi4nO1xuXG4vKlxuICogRGVmYXVsdCBwYXJhbWV0ZXJzXG4gKi9cblxuLyoqXG4gKiBEZWZhdWx0IGluaXRpYWwgZGVsYXkgZm9yIHRoZSBmaXJzdCByZXRyeSAoaW4gbWlsbGlzZWNvbmRzKS5cbiAqXG4gKiBOb3RlIHRoYXQgTm9kZS5qcyBgc2V0VGltZW91dGAgaGFzIGEgcmVzb2x1dGlvbiBvZiAxbXMsIHNvXG4gKiB0aGUgYWN0dWFsIGRlbGF5IG1heSBiZSBzbGlnaHRseSBsb25nZXIuXG4gKi9cbmNvbnN0IERFRkFVTFRfSU5JVElBTF9ERUxBWV9NUyA9IDAuNTtcblxuLyoqXG4gKiBEZWZhdWx0IGdyb3d0aCBmYWN0b3IgZm9yIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAqL1xuY29uc3QgREVGQVVMVF9HUk9XVEhfRkFDVE9SID0gMjtcblxuLyoqXG4gKiBEZWZhdWx0IG1heGltdW0gZGVsYXkgdG8gY2FwIHRoZSBleHBvbmVudGlhbCBncm93dGggKGluIG1pbGxpc2Vjb25kcylcbiAqL1xuY29uc3QgREVGQVVMVF9NQVhfQkFDS09GRl9NUyA9IDguMDtcblxuLyoqXG4gKiBQcm9wZXJ0aWVzIGZvciBjb25maWd1cmluZyB0aGUgRXhwb25lbnRpYWxCYWNrb2ZmUmV0cnlTdHJhdGVneVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEV4cG9uZW50aWFsQmFja29mZlJldHJ5U3RyYXRlZ3lQcm9wcyB7XG4gIC8qKlxuICAgKiBDb25maWd1cmVzIGxvZ2dpbmcgdmVyYm9zaXR5IGFuZCBmb3JtYXRcbiAgICovXG4gIGxvZ2dlckZhY3Rvcnk6IE1vbWVudG9Mb2dnZXJGYWN0b3J5O1xuICAvKipcbiAgICogQ29uZmlndXJlcyBob3cgYW5kIHdoZW4gZmFpbGVkIHJlcXVlc3RzIHdpbGwgYmUgcmV0cmllZFxuICAgKi9cbiAgZWxpZ2liaWxpdHlTdHJhdGVneT86IEVsaWdpYmlsaXR5U3RyYXRlZ3k7XG5cbiAgLyoqXG4gICAqIEluaXRpYWwgZGVsYXkgZm9yIHRoZSBmaXJzdCByZXRyeSAoaW4gbWlsbGlzZWNvbmRzKVxuICAgKi9cbiAgaW5pdGlhbERlbGF5TWlsbGlzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBNYXhpbXVtIGRlbGF5IHRvIGNhcCB0aGUgZXhwb25lbnRpYWwgZ3Jvd3RoIChpbiBtaWxsaXNlY29uZHMpXG4gICAqL1xuICBtYXhCYWNrb2ZmTWlsbGlzPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIFJldHJ5IHN0cmF0ZWd5IHRoYXQgdXNlcyBleHBvbmVudGlhbCBiYWNrb2ZmIHdpdGggZGVjb3JyZWxhdGVkIGppdHRlci5cbiAqXG4gKiBUaGUgYmFja29mZiBmb3IgZWFjaCBhdHRlbXB0IGlzIGNhbGN1bGF0ZWQgYXMgZm9sbG93czpcbiAqIC0gVGhlIGZpcnN0IHJldHJ5IGhhcyBhIGZpeGVkIGRlbGF5IG9mIGBpbml0aWFsRGVsYXlNaWxsaXNgXG4gKiAtIEJhY2tvZmYgZm9yIHN1YnNlcXVlbnQgcmV0cmllcyBpcyBjYWxjdWxhdGVkIGFzIGBpbml0aWFsRGVsYXlNaWxsaXMgKiAyXmF0dGVtcHROdW1iZXJgXG4gKiAtIFN1YnNlcXVlbnQgcmV0cmllcyBoYXZlIGEgZGVsYXkgdGhhdCBpcyBhIHJhbmRvbSB2YWx1ZSBiZXR3ZWVuXG4gKiAgIHRoZSBjdXJyZW50IGJhY2tvZmYgYW5kIDMgdGltZXMgdGhlIHByZXZpb3VzIGJhY2tvZmYsIHdpdGggdGhlXG4gKi4gIGN1cnJlbnQgYmFja29mZiBjYXBwZWQgYXQgYG1heEJhY2tvZmZNaWxsaXNgXG4gKi9cbmV4cG9ydCBjbGFzcyBFeHBvbmVudGlhbEJhY2tvZmZSZXRyeVN0cmF0ZWd5IGltcGxlbWVudHMgUmV0cnlTdHJhdGVneSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyOiBNb21lbnRvTG9nZ2VyO1xuICBwcml2YXRlIHJlYWRvbmx5IGVsaWdpYmlsaXR5U3RyYXRlZ3k6IEVsaWdpYmlsaXR5U3RyYXRlZ3k7XG4gIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbERlbGF5TWlsbGlzOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgZ3Jvd3RoRmFjdG9yOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgbWF4QmFja29mZk1pbGxpczogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBFeHBvbmVudGlhbEJhY2tvZmZSZXRyeVN0cmF0ZWd5UHJvcHMpIHtcbiAgICB0aGlzLmxvZ2dlciA9IHByb3BzLmxvZ2dlckZhY3RvcnkuZ2V0TG9nZ2VyKHRoaXMpO1xuICAgIHRoaXMuZWxpZ2liaWxpdHlTdHJhdGVneSA9XG4gICAgICBwcm9wcy5lbGlnaWJpbGl0eVN0cmF0ZWd5ID8/XG4gICAgICBuZXcgRGVmYXVsdEVsaWdpYmlsaXR5U3RyYXRlZ3kocHJvcHMubG9nZ2VyRmFjdG9yeSk7XG5cbiAgICB0aGlzLmluaXRpYWxEZWxheU1pbGxpcyA9XG4gICAgICBwcm9wcy5pbml0aWFsRGVsYXlNaWxsaXMgPz8gREVGQVVMVF9JTklUSUFMX0RFTEFZX01TO1xuICAgIHRoaXMuZ3Jvd3RoRmFjdG9yID0gREVGQVVMVF9HUk9XVEhfRkFDVE9SO1xuICAgIHRoaXMubWF4QmFja29mZk1pbGxpcyA9IHByb3BzLm1heEJhY2tvZmZNaWxsaXMgPz8gREVGQVVMVF9NQVhfQkFDS09GRl9NUztcbiAgfVxuXG4gIGRldGVybWluZVdoZW5Ub1JldHJ5UmVxdWVzdChcbiAgICBwcm9wczogRGV0ZXJtaW5ld2hlblRvUmV0cnlSZXF1ZXN0UHJvcHNcbiAgKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICBgRGV0ZXJtaW5pbmcgd2hldGhlciByZXF1ZXN0IGlzIGVsaWdpYmxlIGZvciByZXRyeTsgc3RhdHVzIGNvZGU6ICR7cHJvcHMuZ3JwY1N0YXR1cy5jb2RlfSwgcmVxdWVzdCB0eXBlOiAke3Byb3BzLmdycGNSZXF1ZXN0LnBhdGh9LCBhdHRlbXB0TnVtYmVyOiAke3Byb3BzLmF0dGVtcHROdW1iZXJ9YFxuICAgICk7XG5cbiAgICBpZiAoIXRoaXMuZWxpZ2liaWxpdHlTdHJhdGVneS5pc0VsaWdpYmxlRm9yUmV0cnkocHJvcHMpKSB7XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnUmVxdWVzdCBpcyBub3QgZWxpZ2libGUgZm9yIHJldHJ5LicpO1xuICAgICAgcmV0dXJuIG51bGw7IC8vIERvIG5vdCByZXRyeVxuICAgIH1cblxuICAgIGNvbnN0IGJhc2VEZWxheSA9IE1hdGgubWluKFxuICAgICAgdGhpcy5jb21wdXRlQmFzZURlbGF5KHByb3BzLmF0dGVtcHROdW1iZXIpLFxuICAgICAgdGhpcy5tYXhCYWNrb2ZmTWlsbGlzXG4gICAgKTtcbiAgICBjb25zdCBwcmV2aW91c0Jhc2VEZWxheSA9IHRoaXMuY29tcHV0ZVByZXZpb3VzQmFzZURlbGF5KGJhc2VEZWxheSk7XG4gICAgY29uc3QgbWF4RGVsYXkgPSBwcmV2aW91c0Jhc2VEZWxheSAqIDM7XG4gICAgY29uc3Qgaml0dGVyZWREZWxheSA9IHJhbmRvbUluUmFuZ2UoYmFzZURlbGF5LCBtYXhEZWxheSk7XG5cbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgIGBFeHBvbmVudGlhbEJhY2tvZmZSZXRyeVN0cmF0ZWd5OiBhdHRlbXB0ICMke3Byb3BzLmF0dGVtcHROdW1iZXJ9YCArXG4gICAgICAgIGAgLT4gYmFzZSBkZWxheT0ke2Jhc2VEZWxheX1tcywgbWF4IGRlbGF5PSR7bWF4RGVsYXl9bXMsIGppdHRlcmVkIGRlbGF5PSR7aml0dGVyZWREZWxheX1tc2BcbiAgICApO1xuXG4gICAgcmV0dXJuIGppdHRlcmVkRGVsYXk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgYmFja29mZmVkIGJhc2UgZGVsYXkgZm9yIHRoZSBnaXZlbiBhdHRlbXB0IG51bWJlci5cbiAgICogQHBhcmFtIGF0dGVtcHROdW1iZXIgLSBUaGUgYXR0ZW1wdCBudW1iZXIgKDAtYmFzZWQpXG4gICAqIEByZXR1cm5zIFRoZSBiYXNlIGRlbGF5IGZvciB0aGUgZ2l2ZW4gYXR0ZW1wdCBudW1iZXJcbiAgICovXG4gIHByaXZhdGUgY29tcHV0ZUJhc2VEZWxheShhdHRlbXB0TnVtYmVyOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChhdHRlbXB0TnVtYmVyIDw9IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxEZWxheU1pbGxpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5pbml0aWFsRGVsYXlNaWxsaXMgKiBNYXRoLnBvdyh0aGlzLmdyb3d0aEZhY3RvciwgYXR0ZW1wdE51bWJlcilcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb21wdXRlUHJldmlvdXNCYXNlRGVsYXkoY3VycmVudEJhc2VEZWxheTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gY3VycmVudEJhc2VEZWxheSAvIHRoaXMuZ3Jvd3RoRmFjdG9yO1xuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSB1bmlmb3JtIHJhbmRvbSBudW1iZXIgaW4gdGhlIHJhbmdlIFttaW4sIG1heClcbiAqIEBwYXJhbSBtaW4gLSBNaW5pbXVtIHZhbHVlIChpbmNsdXNpdmUpXG4gKiBAcGFyYW0gbWF4IC0gTWF4aW11bSB2YWx1ZSAoZXhjbHVzaXZlKVxuICogQHJldHVybnMgQSByYW5kb20gbnVtYmVyIGluIHRoZSByYW5nZSBbbWluLCBtYXgpXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUluUmFuZ2UobWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKG1pbiA+PSBtYXgpIHtcbiAgICByZXR1cm4gbWluO1xuICB9XG4gIHJldHVybiByb3VuZChtaW4gKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiksIDMpO1xufVxuXG4vKipcbiAqIFJvdW5kIGEgbnVtYmVyIHRvIGEgZ2l2ZW4gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJvdW5kXG4gKiBAcGFyYW0gZGVjaW1hbHMgLSBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gKiBAcmV0dXJucyBUaGUgcm91bmRlZCB2YWx1ZVxuICovXG5mdW5jdGlvbiByb3VuZCh2YWx1ZTogbnVtYmVyLCBkZWNpbWFsczogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgZmFjdG9yID0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBmYWN0b3IpIC8gZmFjdG9yO1xufVxuIl19
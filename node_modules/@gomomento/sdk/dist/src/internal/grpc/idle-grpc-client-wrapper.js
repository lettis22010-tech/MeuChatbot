"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IdleGrpcClientWrapper = void 0;
const connectivity_state_1 = require("@grpc/grpc-js/build/src/connectivity-state");
/**
 * This wrapper allows us to ensure that a grpc client is not re-used if it has been idle
 * for longer than a specified period of time.  This is important in some environments,
 * such as AWS Lambda, where the runtime may be paused indefinitely between invocations.
 * In such cases we have observed that while the runtime is suspended, the connection
 * may have been closed by the server. (e.g., AWS NLB has an idle timeout of 350s:
 * https://docs.aws.amazon.com/elasticloadbalancing/latest/network/network-load-balancers.html#connection-idle-timeout )
 * When the runtime resumes, it does not recognize that the connection has been closed,
 * and it may continue to attempt to send bytes to it, resulting in client-side timeouts
 * (DEADLINE_EXCEEDED).  Forcefully refreshing the client if it has been idle for too
 * long will prevent this.
 *
 * NOTE: We can't rely on keepalive pings in this scenario, because the lambda runtime
 * may be suspended in such a way that background tasks such as the keepalive pings
 * will not be able to execute.
 */
class IdleGrpcClientWrapper {
    constructor(props) {
        this.CLOSE_CLIENT_TIMEOUT_MULTIPLIER = 2;
        this.isRecreating = false;
        this.logger = props.loggerFactory.getLogger(this);
        this.clientFactoryFn = props.clientFactoryFn;
        this.client = this.clientFactoryFn();
        this.maxIdleMillis = props.maxIdleMillis;
        this.lastAccessTime = Date.now();
        this.maxClientAgeMillis = props.maxClientAgeMillis;
        this.clientCreatedTime = Date.now();
        this.clientTimeoutMillis = props.clientTimeoutMillis;
    }
    getClient() {
        var _a;
        const now = Date.now();
        // Prevent double recreation if already in progress
        if (this.isRecreating) {
            this.logger.debug('Client recreation in progress; returning existing client.');
            return this.client;
        }
        // Check if client should be reconnected due to bad state, idle timeout, or age
        if (!this.shouldReconnect(now)) {
            this.lastAccessTime = now;
            return this.client;
        }
        try {
            this.isRecreating = true;
            return this.recreateClient((_a = this.reconnectReason) !== null && _a !== void 0 ? _a : 'Unknown reason');
        }
        finally {
            this.isRecreating = false;
        }
    }
    /**
     * Encapsulates all reconnect triggers.
     */
    shouldReconnect(now) {
        var _a;
        // Reconnect if channel is in a bad state.
        // Although the generic type `T` only extends `CloseableGrpcClient` (which doesn't define `getChannel()`),
        // we know that in practice, the client returned by `clientFactoryFn()` is a gRPC client that inherits from
        // `grpc.Client`: https://grpc.github.io/grpc/node/grpc.Client.html
        //
        // Since `grpc.Client` defines a public `getChannel()` method, we can safely assume it's present on the client.
        // To make TypeScript accept this, we cast the client to `unknown` first and then to `GrpcClientWithChannel`.
        // This double-cast is necessary to override structural type checking and is safe in our controlled use case.
        const clientWithChannel = this.client;
        const channel = (_a = clientWithChannel.getChannel) === null || _a === void 0 ? void 0 : _a.call(clientWithChannel);
        if (channel) {
            const state = channel.getConnectivityState(true);
            if (state === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE ||
                state === connectivity_state_1.ConnectivityState.SHUTDOWN) {
                this.reconnectReason = `gRPC channel is in bad state: ${connectivity_state_1.ConnectivityState[state]}`;
                return true;
            }
        }
        if (now - this.lastAccessTime > this.maxIdleMillis) {
            this.reconnectReason = `Client has been idle for more than ${this.maxIdleMillis} ms`;
            return true;
        }
        if (this.maxClientAgeMillis !== undefined &&
            now - this.clientCreatedTime > this.maxClientAgeMillis) {
            this.reconnectReason = `Client was created more than ${this.maxClientAgeMillis} ms ago`;
            return true;
        }
        return false;
    }
    /**
     * Replaces the current client with a new one.
     * Caller must ensure `isRecreating` is true before calling this.
     */
    recreateClient(reason) {
        this.logger.info(`${reason}; reconnecting client.`);
        const oldClient = this.client;
        // Delay closing the old client to allow in-flight requests to complete
        const closeDelay = this.clientTimeoutMillis * this.CLOSE_CLIENT_TIMEOUT_MULTIPLIER;
        setTimeout(() => {
            this.logger.debug('Closing old client after grace period of %d ms', closeDelay);
            oldClient.close();
        }, closeDelay);
        this.client = this.clientFactoryFn();
        const now = Date.now();
        this.clientCreatedTime = now;
        this.lastAccessTime = now;
        return this.client;
    }
}
exports.IdleGrpcClientWrapper = IdleGrpcClientWrapper;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWRsZS1ncnBjLWNsaWVudC13cmFwcGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2ludGVybmFsL2dycGMvaWRsZS1ncnBjLWNsaWVudC13cmFwcGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQU1BLG1GQUE2RTtBQVU3RTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCxNQUFhLHFCQUFxQjtJQWtCaEMsWUFBWSxLQUFvQztRQUx4QyxvQ0FBK0IsR0FBRyxDQUFDLENBQUM7UUFFcEMsaUJBQVksR0FBRyxLQUFLLENBQUM7UUFJM0IsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMsZUFBZSxHQUFHLEtBQUssQ0FBQyxlQUFlLENBQUM7UUFDN0MsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDckMsSUFBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDO1FBQ3pDLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxLQUFLLENBQUMsa0JBQWtCLENBQUM7UUFDbkQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNwQyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsS0FBSyxDQUFDLG1CQUFtQixDQUFDO0lBQ3ZELENBQUM7SUFFRCxTQUFTOztRQUNQLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUV2QixtREFBbUQ7UUFDbkQsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3JCLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUNmLDJEQUEyRCxDQUM1RCxDQUFDO1lBQ0YsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO1NBQ3BCO1FBRUQsK0VBQStFO1FBQy9FLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzlCLElBQUksQ0FBQyxjQUFjLEdBQUcsR0FBRyxDQUFDO1lBQzFCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztTQUNwQjtRQUVELElBQUk7WUFDRixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztZQUN6QixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBQSxJQUFJLENBQUMsZUFBZSxtQ0FBSSxnQkFBZ0IsQ0FBQyxDQUFDO1NBQ3RFO2dCQUFTO1lBQ1IsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7U0FDM0I7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxlQUFlLENBQUMsR0FBVzs7UUFDakMsMENBQTBDO1FBQzFDLDBHQUEwRztRQUMxRywyR0FBMkc7UUFDM0csbUVBQW1FO1FBQ25FLEVBQUU7UUFDRiwrR0FBK0c7UUFDL0csNkdBQTZHO1FBQzdHLDZHQUE2RztRQUM3RyxNQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQyxNQUEwQyxDQUFDO1FBQzFFLE1BQU0sT0FBTyxHQUFHLE1BQUEsaUJBQWlCLENBQUMsVUFBVSxpRUFBSSxDQUFDO1FBQ2pELElBQUksT0FBTyxFQUFFO1lBQ1gsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2pELElBQ0UsS0FBSyxLQUFLLHNDQUFpQixDQUFDLGlCQUFpQjtnQkFDN0MsS0FBSyxLQUFLLHNDQUFpQixDQUFDLFFBQVEsRUFDcEM7Z0JBQ0EsSUFBSSxDQUFDLGVBQWUsR0FBRyxpQ0FBaUMsc0NBQWlCLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztnQkFDbkYsT0FBTyxJQUFJLENBQUM7YUFDYjtTQUNGO1FBRUQsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ2xELElBQUksQ0FBQyxlQUFlLEdBQUcsc0NBQXNDLElBQUksQ0FBQyxhQUFhLEtBQUssQ0FBQztZQUNyRixPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsSUFDRSxJQUFJLENBQUMsa0JBQWtCLEtBQUssU0FBUztZQUNyQyxHQUFHLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxrQkFBa0IsRUFDdEQ7WUFDQSxJQUFJLENBQUMsZUFBZSxHQUFHLGdDQUFnQyxJQUFJLENBQUMsa0JBQWtCLFNBQVMsQ0FBQztZQUN4RixPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssY0FBYyxDQUFDLE1BQWM7UUFDbkMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLHdCQUF3QixDQUFDLENBQUM7UUFDcEQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUU5Qix1RUFBdUU7UUFDdkUsTUFBTSxVQUFVLEdBQ2QsSUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksQ0FBQywrQkFBK0IsQ0FBQztRQUNsRSxVQUFVLENBQUMsR0FBRyxFQUFFO1lBQ2QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQ2YsZ0RBQWdELEVBQ2hELFVBQVUsQ0FDWCxDQUFDO1lBQ0YsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3BCLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUVmLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3JDLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsaUJBQWlCLEdBQUcsR0FBRyxDQUFDO1FBQzdCLElBQUksQ0FBQyxjQUFjLEdBQUcsR0FBRyxDQUFDO1FBQzFCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNyQixDQUFDO0NBQ0Y7QUF4SEQsc0RBd0hDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2xvc2VhYmxlR3JwY0NsaWVudCxcbiAgR3JwY0NsaWVudFdpdGhDaGFubmVsLFxuICBHcnBjQ2xpZW50V3JhcHBlcixcbn0gZnJvbSAnLi9ncnBjLWNsaWVudC13cmFwcGVyJztcbmltcG9ydCB7TW9tZW50b0xvZ2dlciwgTW9tZW50b0xvZ2dlckZhY3Rvcnl9IGZyb20gJ0Bnb21vbWVudG8vc2RrLWNvcmUnO1xuaW1wb3J0IHtDb25uZWN0aXZpdHlTdGF0ZX0gZnJvbSAnQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29ubmVjdGl2aXR5LXN0YXRlJztcblxuZXhwb3J0IGludGVyZmFjZSBJZGxlR3JwY0NsaWVudFdyYXBwZXJQcm9wczxUIGV4dGVuZHMgQ2xvc2VhYmxlR3JwY0NsaWVudD4ge1xuICBjbGllbnRGYWN0b3J5Rm46ICgpID0+IFQ7XG4gIGxvZ2dlckZhY3Rvcnk6IE1vbWVudG9Mb2dnZXJGYWN0b3J5O1xuICBjbGllbnRUaW1lb3V0TWlsbGlzOiBudW1iZXI7XG4gIG1heElkbGVNaWxsaXM6IG51bWJlcjtcbiAgbWF4Q2xpZW50QWdlTWlsbGlzPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIFRoaXMgd3JhcHBlciBhbGxvd3MgdXMgdG8gZW5zdXJlIHRoYXQgYSBncnBjIGNsaWVudCBpcyBub3QgcmUtdXNlZCBpZiBpdCBoYXMgYmVlbiBpZGxlXG4gKiBmb3IgbG9uZ2VyIHRoYW4gYSBzcGVjaWZpZWQgcGVyaW9kIG9mIHRpbWUuICBUaGlzIGlzIGltcG9ydGFudCBpbiBzb21lIGVudmlyb25tZW50cyxcbiAqIHN1Y2ggYXMgQVdTIExhbWJkYSwgd2hlcmUgdGhlIHJ1bnRpbWUgbWF5IGJlIHBhdXNlZCBpbmRlZmluaXRlbHkgYmV0d2VlbiBpbnZvY2F0aW9ucy5cbiAqIEluIHN1Y2ggY2FzZXMgd2UgaGF2ZSBvYnNlcnZlZCB0aGF0IHdoaWxlIHRoZSBydW50aW1lIGlzIHN1c3BlbmRlZCwgdGhlIGNvbm5lY3Rpb25cbiAqIG1heSBoYXZlIGJlZW4gY2xvc2VkIGJ5IHRoZSBzZXJ2ZXIuIChlLmcuLCBBV1MgTkxCIGhhcyBhbiBpZGxlIHRpbWVvdXQgb2YgMzUwczpcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9lbGFzdGljbG9hZGJhbGFuY2luZy9sYXRlc3QvbmV0d29yay9uZXR3b3JrLWxvYWQtYmFsYW5jZXJzLmh0bWwjY29ubmVjdGlvbi1pZGxlLXRpbWVvdXQgKVxuICogV2hlbiB0aGUgcnVudGltZSByZXN1bWVzLCBpdCBkb2VzIG5vdCByZWNvZ25pemUgdGhhdCB0aGUgY29ubmVjdGlvbiBoYXMgYmVlbiBjbG9zZWQsXG4gKiBhbmQgaXQgbWF5IGNvbnRpbnVlIHRvIGF0dGVtcHQgdG8gc2VuZCBieXRlcyB0byBpdCwgcmVzdWx0aW5nIGluIGNsaWVudC1zaWRlIHRpbWVvdXRzXG4gKiAoREVBRExJTkVfRVhDRUVERUQpLiAgRm9yY2VmdWxseSByZWZyZXNoaW5nIHRoZSBjbGllbnQgaWYgaXQgaGFzIGJlZW4gaWRsZSBmb3IgdG9vXG4gKiBsb25nIHdpbGwgcHJldmVudCB0aGlzLlxuICpcbiAqIE5PVEU6IFdlIGNhbid0IHJlbHkgb24ga2VlcGFsaXZlIHBpbmdzIGluIHRoaXMgc2NlbmFyaW8sIGJlY2F1c2UgdGhlIGxhbWJkYSBydW50aW1lXG4gKiBtYXkgYmUgc3VzcGVuZGVkIGluIHN1Y2ggYSB3YXkgdGhhdCBiYWNrZ3JvdW5kIHRhc2tzIHN1Y2ggYXMgdGhlIGtlZXBhbGl2ZSBwaW5nc1xuICogd2lsbCBub3QgYmUgYWJsZSB0byBleGVjdXRlLlxuICovXG5leHBvcnQgY2xhc3MgSWRsZUdycGNDbGllbnRXcmFwcGVyPFQgZXh0ZW5kcyBDbG9zZWFibGVHcnBjQ2xpZW50PlxuICBpbXBsZW1lbnRzIEdycGNDbGllbnRXcmFwcGVyPFQ+XG57XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyOiBNb21lbnRvTG9nZ2VyO1xuXG4gIHByaXZhdGUgY2xpZW50OiBUO1xuICBwcml2YXRlIHJlYWRvbmx5IGNsaWVudEZhY3RvcnlGbjogKCkgPT4gVDtcblxuICBwcml2YXRlIHJlYWRvbmx5IG1heElkbGVNaWxsaXM6IG51bWJlcjtcbiAgcHJpdmF0ZSBsYXN0QWNjZXNzVGltZTogbnVtYmVyO1xuICBwcml2YXRlIGNsaWVudENyZWF0ZWRUaW1lOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgbWF4Q2xpZW50QWdlTWlsbGlzPzogbnVtYmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IGNsaWVudFRpbWVvdXRNaWxsaXM6IG51bWJlcjtcbiAgcHJpdmF0ZSBDTE9TRV9DTElFTlRfVElNRU9VVF9NVUxUSVBMSUVSID0gMjtcblxuICBwcml2YXRlIGlzUmVjcmVhdGluZyA9IGZhbHNlO1xuICBwcml2YXRlIHJlY29ubmVjdFJlYXNvbj86IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogSWRsZUdycGNDbGllbnRXcmFwcGVyUHJvcHM8VD4pIHtcbiAgICB0aGlzLmxvZ2dlciA9IHByb3BzLmxvZ2dlckZhY3RvcnkuZ2V0TG9nZ2VyKHRoaXMpO1xuICAgIHRoaXMuY2xpZW50RmFjdG9yeUZuID0gcHJvcHMuY2xpZW50RmFjdG9yeUZuO1xuICAgIHRoaXMuY2xpZW50ID0gdGhpcy5jbGllbnRGYWN0b3J5Rm4oKTtcbiAgICB0aGlzLm1heElkbGVNaWxsaXMgPSBwcm9wcy5tYXhJZGxlTWlsbGlzO1xuICAgIHRoaXMubGFzdEFjY2Vzc1RpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMubWF4Q2xpZW50QWdlTWlsbGlzID0gcHJvcHMubWF4Q2xpZW50QWdlTWlsbGlzO1xuICAgIHRoaXMuY2xpZW50Q3JlYXRlZFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuY2xpZW50VGltZW91dE1pbGxpcyA9IHByb3BzLmNsaWVudFRpbWVvdXRNaWxsaXM7XG4gIH1cblxuICBnZXRDbGllbnQoKTogVCB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIFByZXZlbnQgZG91YmxlIHJlY3JlYXRpb24gaWYgYWxyZWFkeSBpbiBwcm9ncmVzc1xuICAgIGlmICh0aGlzLmlzUmVjcmVhdGluZykge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgICdDbGllbnQgcmVjcmVhdGlvbiBpbiBwcm9ncmVzczsgcmV0dXJuaW5nIGV4aXN0aW5nIGNsaWVudC4nXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGNsaWVudCBzaG91bGQgYmUgcmVjb25uZWN0ZWQgZHVlIHRvIGJhZCBzdGF0ZSwgaWRsZSB0aW1lb3V0LCBvciBhZ2VcbiAgICBpZiAoIXRoaXMuc2hvdWxkUmVjb25uZWN0KG5vdykpIHtcbiAgICAgIHRoaXMubGFzdEFjY2Vzc1RpbWUgPSBub3c7XG4gICAgICByZXR1cm4gdGhpcy5jbGllbnQ7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuaXNSZWNyZWF0aW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLnJlY3JlYXRlQ2xpZW50KHRoaXMucmVjb25uZWN0UmVhc29uID8/ICdVbmtub3duIHJlYXNvbicpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzUmVjcmVhdGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNhcHN1bGF0ZXMgYWxsIHJlY29ubmVjdCB0cmlnZ2Vycy5cbiAgICovXG4gIHByaXZhdGUgc2hvdWxkUmVjb25uZWN0KG5vdzogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgLy8gUmVjb25uZWN0IGlmIGNoYW5uZWwgaXMgaW4gYSBiYWQgc3RhdGUuXG4gICAgLy8gQWx0aG91Z2ggdGhlIGdlbmVyaWMgdHlwZSBgVGAgb25seSBleHRlbmRzIGBDbG9zZWFibGVHcnBjQ2xpZW50YCAod2hpY2ggZG9lc24ndCBkZWZpbmUgYGdldENoYW5uZWwoKWApLFxuICAgIC8vIHdlIGtub3cgdGhhdCBpbiBwcmFjdGljZSwgdGhlIGNsaWVudCByZXR1cm5lZCBieSBgY2xpZW50RmFjdG9yeUZuKClgIGlzIGEgZ1JQQyBjbGllbnQgdGhhdCBpbmhlcml0cyBmcm9tXG4gICAgLy8gYGdycGMuQ2xpZW50YDogaHR0cHM6Ly9ncnBjLmdpdGh1Yi5pby9ncnBjL25vZGUvZ3JwYy5DbGllbnQuaHRtbFxuICAgIC8vXG4gICAgLy8gU2luY2UgYGdycGMuQ2xpZW50YCBkZWZpbmVzIGEgcHVibGljIGBnZXRDaGFubmVsKClgIG1ldGhvZCwgd2UgY2FuIHNhZmVseSBhc3N1bWUgaXQncyBwcmVzZW50IG9uIHRoZSBjbGllbnQuXG4gICAgLy8gVG8gbWFrZSBUeXBlU2NyaXB0IGFjY2VwdCB0aGlzLCB3ZSBjYXN0IHRoZSBjbGllbnQgdG8gYHVua25vd25gIGZpcnN0IGFuZCB0aGVuIHRvIGBHcnBjQ2xpZW50V2l0aENoYW5uZWxgLlxuICAgIC8vIFRoaXMgZG91YmxlLWNhc3QgaXMgbmVjZXNzYXJ5IHRvIG92ZXJyaWRlIHN0cnVjdHVyYWwgdHlwZSBjaGVja2luZyBhbmQgaXMgc2FmZSBpbiBvdXIgY29udHJvbGxlZCB1c2UgY2FzZS5cbiAgICBjb25zdCBjbGllbnRXaXRoQ2hhbm5lbCA9IHRoaXMuY2xpZW50IGFzIHVua25vd24gYXMgR3JwY0NsaWVudFdpdGhDaGFubmVsO1xuICAgIGNvbnN0IGNoYW5uZWwgPSBjbGllbnRXaXRoQ2hhbm5lbC5nZXRDaGFubmVsPy4oKTtcbiAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSBjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKHRydWUpO1xuICAgICAgaWYgKFxuICAgICAgICBzdGF0ZSA9PT0gQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUgfHxcbiAgICAgICAgc3RhdGUgPT09IENvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RSZWFzb24gPSBgZ1JQQyBjaGFubmVsIGlzIGluIGJhZCBzdGF0ZTogJHtDb25uZWN0aXZpdHlTdGF0ZVtzdGF0ZV19YDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vdyAtIHRoaXMubGFzdEFjY2Vzc1RpbWUgPiB0aGlzLm1heElkbGVNaWxsaXMpIHtcbiAgICAgIHRoaXMucmVjb25uZWN0UmVhc29uID0gYENsaWVudCBoYXMgYmVlbiBpZGxlIGZvciBtb3JlIHRoYW4gJHt0aGlzLm1heElkbGVNaWxsaXN9IG1zYDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHRoaXMubWF4Q2xpZW50QWdlTWlsbGlzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIG5vdyAtIHRoaXMuY2xpZW50Q3JlYXRlZFRpbWUgPiB0aGlzLm1heENsaWVudEFnZU1pbGxpc1xuICAgICkge1xuICAgICAgdGhpcy5yZWNvbm5lY3RSZWFzb24gPSBgQ2xpZW50IHdhcyBjcmVhdGVkIG1vcmUgdGhhbiAke3RoaXMubWF4Q2xpZW50QWdlTWlsbGlzfSBtcyBhZ29gO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IGNsaWVudCB3aXRoIGEgbmV3IG9uZS5cbiAgICogQ2FsbGVyIG11c3QgZW5zdXJlIGBpc1JlY3JlYXRpbmdgIGlzIHRydWUgYmVmb3JlIGNhbGxpbmcgdGhpcy5cbiAgICovXG4gIHByaXZhdGUgcmVjcmVhdGVDbGllbnQocmVhc29uOiBzdHJpbmcpOiBUIHtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKGAke3JlYXNvbn07IHJlY29ubmVjdGluZyBjbGllbnQuYCk7XG4gICAgY29uc3Qgb2xkQ2xpZW50ID0gdGhpcy5jbGllbnQ7XG5cbiAgICAvLyBEZWxheSBjbG9zaW5nIHRoZSBvbGQgY2xpZW50IHRvIGFsbG93IGluLWZsaWdodCByZXF1ZXN0cyB0byBjb21wbGV0ZVxuICAgIGNvbnN0IGNsb3NlRGVsYXkgPVxuICAgICAgdGhpcy5jbGllbnRUaW1lb3V0TWlsbGlzICogdGhpcy5DTE9TRV9DTElFTlRfVElNRU9VVF9NVUxUSVBMSUVSO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgICdDbG9zaW5nIG9sZCBjbGllbnQgYWZ0ZXIgZ3JhY2UgcGVyaW9kIG9mICVkIG1zJyxcbiAgICAgICAgY2xvc2VEZWxheVxuICAgICAgKTtcbiAgICAgIG9sZENsaWVudC5jbG9zZSgpO1xuICAgIH0sIGNsb3NlRGVsYXkpO1xuXG4gICAgdGhpcy5jbGllbnQgPSB0aGlzLmNsaWVudEZhY3RvcnlGbigpO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgdGhpcy5jbGllbnRDcmVhdGVkVGltZSA9IG5vdztcbiAgICB0aGlzLmxhc3RBY2Nlc3NUaW1lID0gbm93O1xuICAgIHJldHVybiB0aGlzLmNsaWVudDtcbiAgfVxufVxuIl19